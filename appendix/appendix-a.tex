\chapter{Python Code}
%\label{chapter:title}

Python code used for designing the structural solution to bank erosion can be found here.

%\emph{Adding source code to your report/thesis is supported with the package {\normalfont\texttt{listings}}. An example can be found below. Files can be added using {\normalfont\texttt{\textbackslash lstinputlisting[language=<language>]\{<filename>\}}}.}

\begin{comment}
\begin{lstlisting}[language=Python]
"""
ISA Calculator: import the function, specify the height and it will return a
list in the following format: [Temperature,Density,Pressure,Speed of Sound].
Note that there is no check to see if the maximum altitude is reached.
"""

import math
g0 = 9.80665
R = 287.0
layer1 = [0, 288.15, 101325.0]
alt = [0,11000,20000,32000,47000,51000,71000,86000]
a = [-.0065,0,.0010,.0028,0,-.0028,-.0020]

def atmosphere(h):
    for i in range(0,len(alt)-1):
        if h >= alt[i]:
            layer0 = layer1[:]
            layer1[0] = min(h,alt[i+1])
            if a[i] != 0:
                layer1[1] = layer0[1] + a[i]*(layer1[0]-layer0[0])
                layer1[2] = layer0[2] * (layer1[1]/layer0[1])**(-g0/(a[i]*R))
            else:
                layer1[2] = layer0[2]*math.exp((-g0/(R*layer1[1]))*(layer1[0]-layer0[0]))
    return [layer1[1],layer1[2]/(R*layer1[1]),layer1[2],math.sqrt(1.4*R*layer1[1])]
\end{lstlisting}
\end{comment}

\section{Parameters}

\begin{lstlisting}[language=Python]
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
from dataclasses import dataclass
from typing import Optional, Tuple, List
from io import StringIO

params = dict(
    # Geometry
    Z=4.0,                # Retained height (Z)
    t=6.0,                 # Embedment depth (t)
    alpha_deg=0.0,         # α: wall inclination with vertical (deg)
    beta_left_deg=0.0,     # β (left): ground slope near toe (deg)
    beta_right_deg=0.0,    # β (right/top): ground slope (deg)
    wall_thickness=0.05,    # visual wall thickness
    water_table_depth=1.47,   # water table depth
    water_level = 2.36,

    # Dimension placement
    dim_offset=4,            # horizontal offset (to the right of wall) for Z and t dimensions
    figsize=(16, 10),        # bigger figure to avoid overlap      
    layer_block_width=9.0,   # wider stratigraphy block
    min_layer_thk_for_params=1.1,  # only print γ,c,φ if layer is at least this thick [m]
)

COMMON_X_MIN = -12
COMMON_X_MAX = params["dim_offset"] + params["layer_block_width"]
COMMON_Y_MIN = -params["t"]
COMMON_Y_MAX = params["Z"]
fs=8

LINE_BREAK = chr(10)

def apply_common_axes(ax):
    ax.set_aspect("equal", adjustable="box")
    ax.set_xlim(COMMON_X_MIN, COMMON_X_MAX)
    ax.set_ylim(COMMON_Y_MIN, COMMON_Y_MAX)
\end{lstlisting}

\section{Geometry of the profile}

\begin{lstlisting}[language=Python]
def rot2d(points, angle_deg):
    a = np.deg2rad(angle_deg)
    R = np.array([[np.cos(a), -np.sin(a)], [np.sin(a),  np.cos(a)]])
    return (R @ points.T).T

def draw_arrow(ax, start, vec, head_width=0.25, head_length=0.4, lw=2):
    ax.arrow(start[0], start[1], vec[0], vec[1],
             length_includes_head=True, head_width=head_width,
             head_length=head_length, color="red", linewidth=lw)

def draw_dimension(ax, x, y0, y1, text, fs):
    """Vertical double-headed dimension with text placed to the right."""
    # Double-headed arrow
    ax.annotate('', xy=(x, y1), xytext=(x, y0),
                arrowprops=dict(arrowstyle='<->', color='black', linewidth=1.8))
    ymid = 0.5*(y0 + y1)
    ax.text(x + 0.35, ymid, text, rotation=90, va='center', fontsize=fs, color='black')

def label_horizontal_line(ax, y, text, x=-11.5, fs=fs, offset_pts=6):
    """Label a horizontal line at y with a small upward screen-space offset."""
    ax.annotate(text, xy=(x, y), xytext=(0, offset_pts),
                textcoords='offset points', ha='left', va='bottom', fontsize=fs, color='black')

Z       = params["Z"]
t       = params["t"]
alpha   = params["alpha_deg"]
betaL   = params["beta_left_deg"]
betaR   = params["beta_right_deg"]
delta   = params["delta_deg"]
wall_th = params["wall_thickness"]
fs      = params["font_size"]

fig, ax = plt.subplots(figsize=params["figsize"])

# Reference horizontal (dashed) through toe at y=0
# ax.plot([-5, 0], [0, 0], linestyle="--", linewidth=1.5, color="black")
# ax.plot([0, 5], [Z, Z], linestyle="--", linewidth=1.5, color="black")
label_horizontal_line(ax, Z, "Ground Surface [+2.5]", x=0.25, fs=8, offset_pts=6)
label_horizontal_line(ax, 0.0, "Dredge Level [-1.5]",  x=-4, fs=8, offset_pts=6)

# Water table depth
ax.plot([0, 4], [Z - params["water_table_depth"], Z - params["water_table_depth"]], linestyle="--", linewidth=1.5, color="black")
label_horizontal_line(ax, Z - params["water_table_depth"], "GWT [+1.03]", x=0.25, fs=8, offset_pts=6)

# Water level
ax.plot([-4, 0], [Z - params["water_level"], Z - params["water_level"]], linestyle="--", linewidth=1.5, color="black")
label_horizontal_line(ax, Z - params["water_level"], "WL [+0.14]", x=-4, fs=8, offset_pts=6)

# Wall direction
theta_wall = 90.0 - alpha
u = np.array([np.cos(np.deg2rad(theta_wall)), np.sin(np.deg2rad(theta_wall))])
toe  = np.array([0.0, 0.0])
top  = toe + u * Z
base = toe - u * t
n = np.array([-u[1], u[0]])

# Wall polygon (thick)
p1 = top  + n * (wall_th/2)
p2 = base + n * (wall_th/2)
p3 = base - n * (wall_th/2)
p4 = top  - n * (wall_th/2)
ax.plot([p1[0], p2[0], p3[0], p4[0], p1[0]],
        [p1[1], p2[1], p3[1], p4[1], p1[1]], color="black", linewidth=3)
# ax.fill_betweenx([COMMON_Y_MIN, COMMON_Y_MAX], p2[0], p3[0], color="black", zorder=0)

# Left ground (through toe) and right ground (through top)
len_ground = params['dim_offset']
left_end = np.array([-len_ground, -np.tan(np.deg2rad(betaL)) * len_ground])
right_end = top + np.array([len_ground, np.tan(np.deg2rad(betaR)) * len_ground])
# attach left ground to the left face of the wall (at toe level)
left_attach = toe + n * (wall_th/2)
ax.plot([left_attach[0], left_end[0]], [left_attach[1], left_end[1]], linewidth=3, color="black")
ax.plot([top[0], right_end[0]], [top[1], right_end[1]], linewidth=3, color="black")

dim_x = max(top[0], p1[0], p4[0]) + params["dim_offset"]
draw_dimension(ax, 2.5, 0.0, top[1], f"Z = {Z:g} m", 8)
draw_dimension(ax, 2.5, -t, 0.0, f"t = {t:g} m", 8)
draw_dimension(ax, 4, Z - params["water_table_depth"], Z, f"$Z_{{2}} = {params['water_table_depth']:g}$ m", 8)
draw_dimension(ax, 4, 0.0, Z - params["water_table_depth"], f"$Z_{{1}} = {Z - params['water_table_depth']:g}$ m", 8)

# Wall face & scaling
x_wall = top[0] + 0.3
block_w = params["dim_offset"]
target  = 0.40 * block_w

half_span = max(abs(COMMON_X_MIN - x_wall), abs(COMMON_X_MAX - x_wall))
ax.set_xlim(x_wall - half_span, x_wall + half_span)
ax.set_ylim(COMMON_Y_MIN, COMMON_Y_MAX + 1)

# position the axes in the middle of the figure canvas
dw = desired_width if 'desired_width' in globals() else 0.6
dh = desired_height if 'desired_height' in globals() else 0.8
left = (1.0 - dw) / 2.0
bottom = (1.0 - dh) / 2.0
ax.set_position([left, bottom, dw, dh])

ax.axis("off")
plt.show()
\end{lstlisting}

% \section{Soil profile}

% \begin{lstlisting}[language=Python]
% @dataclass
% class SoilParams:
%     unit_weight: Optional[float] = None    # γ [kN/m³]
%     cohesion: Optional[float] = None       # c [kPa]
%     phi: Optional[float] = None            # φ [°]
%     delta: Optional[float] = None          # δ [°]
%     k_subgrade: Optional[float] = None     # k [kN/m³]
%     modulus_E: Optional[float] = None      # E [MPa]
%     permeability_k: Optional[float] = None # kperm [m/s]
%     unit_weight_sat: Optional[float] = None  # γ_sat [kN/m³]

% @dataclass
% class Layer:
%     name: str
%     top_depth: float         # depth from right ground surface, positive downward [m]
%     bottom_depth: float      # depth from right ground surface, positive downward [m]
%     params: SoilParams
%     color: str = "#dddddd"

% layers: List[Layer] = [
%     Layer("Fill",             0.0,   2.0,  SoilParams(unit_weight=12.0, cohesion=20, phi=15.0, unit_weight_sat=12.0)),
%     Layer("Fine–Medium Sand", 2.0,   7.0,  SoilParams(unit_weight=17.0, cohesion=0,  phi=30,   unit_weight_sat=19.0)),
%     Layer("Clay",             7.0,  10.0,  SoilParams(unit_weight=14.0, cohesion=25, phi=17.5, unit_weight_sat=14.0)),
%     Layer("Clayey Sand",     10.0,  15.0,  SoilParams(unit_weight=18.0, cohesion=0,  phi=25,   unit_weight_sat=20.0)),
%     Layer("Clay",            15.0,  16.0,  SoilParams(unit_weight=14.0, cohesion=25, phi=17.5, unit_weight_sat=14.0)),
%     Layer("Clayey Sand",     16.0,  17.5,  SoilParams(unit_weight=18.0, cohesion=0,  phi=25,   unit_weight_sat=20.0)),
%     Layer("Medium Sand",     17.5,  32.5,  SoilParams(unit_weight=18.0, cohesion=0,  phi=32.5, unit_weight_sat=20.0)),
% ]

% def rot2d(points, angle_deg):
%     a = np.deg2rad(angle_deg)
%     R = np.array([[np.cos(a), -np.sin(a)], [np.sin(a),  np.cos(a)]])
%     return (R @ points.T).T

% def draw_arrow(ax, start, vec, head_width=0.25, head_length=0.4, lw=2, color="red"):
%     ax.arrow(start[0], start[1], vec[0], vec[1],
%              length_includes_head=True, head_width=head_width,
%              head_length=head_length, color=color, linewidth=lw)

% def draw_P_arrows_perp_to_segment(ax, A, B, n_arrows, length, fs, label, offset=1.35, color="red"):
%     # Skip drawing if "length" is 0 or negative (P=0 rule)
%     if n_arrows <= 0 or length <= 0:
%         return
%     A = np.array(A, dtype=float)
%     B = np.array(B, dtype=float)
%     seg = B - A
%     L = np.linalg.norm(seg)
%     if L == 0:
%         return
%     s = seg / L
%     n1 = np.array([-s[1], s[0]])
%     n_out = n1 if n1[1] >= 0 else -n1
%     ts = np.linspace(0.1, 0.9, n_arrows)
%     tips = [A + t * seg for t in ts]
%     for tip in tips:
%         start = tip + n_out * length
%         ax.arrow(start[0], start[1],
%                  (-n_out * length)[0], (-n_out * length)[1],
%                  length_includes_head=True,
%                  head_width=0.25, head_length=0.4,
%                  color=color, linewidth=2)
%     # place label a bit above the arrows
%     mid_tip = tips[len(tips)//2]
%     label_pos = mid_tip + n_out * (offset * length)
%     ax.text(label_pos[0], label_pos[1], label,
%             fontsize=fs, ha="center", va="bottom", color="black")

% def draw_dimension(ax, x, y0, y1, text, fs):
%     ax.annotate('', xy=(x, y1), xytext=(x, y0),
%                 arrowprops=dict(arrowstyle='<->', color='black', linewidth=1.8))
%     ymid = 0.5*(y0 + y1)
%     ax.text(x + 0.5, ymid, text, rotation=90, va='center', fontsize=fs, color='black')

% def draw_layers_right_dashed(ax, top_point, block_width, layers,
%                              fs=fs, show_params=True, min_thk=0.5,
%                              dash_pattern=(6, 4), max_depth=None):
%     """
%     Draw soil layers to the RIGHT of the wall using ONLY dashed horizontal lines.
%     - Layer name centered in the layer
%     - Only γ, c, φ printed under the name (and only if the layer is thick enough)
%     """
%     x0, y_top = top_point
%     xL = x0 
%     xR = xL + params['dim_offset']

%     # ----- decide depth limit
%     if max_depth is None:
%         max_depth = max(lyr.bottom_depth for lyr in layers)

%     # ----- build a clipped list of layers
%     clipped = []
%     for lyr in layers:
%         if lyr.top_depth >= max_depth:
%             continue
%         top_d = lyr.top_depth
%         bot_d = min(lyr.bottom_depth, max_depth)
%         if bot_d - top_d <= 1e-9:
%             continue
%         # keep same params/color
%         clipped.append(Layer(lyr.name, top_d, bot_d, lyr.params, lyr.color))

%     # --- draw dashed boundaries for all unique layer interfaces
%     boundaries = []
%     for lyr in layers:
%         boundaries.append(y_top - lyr.top_depth)
%         boundaries.append(y_top - lyr.bottom_depth)

%     boundaries = sorted(boundaries)
%     eps = 1e-6
%     last = None
%     for y in boundaries:
%         if last is None or abs(y - last) > eps:
%             ax.plot([xL, xR], [y, y],
%                     linestyle=(0, dash_pattern), linewidth=1.2, color="black")
%             last = y

%     # --- labels at TOP (lock to dashed line; use screen offsets)
%     for lyr in layers:
%         y1 = y_top - lyr.top_depth      # top boundary of layer (dashed line)
%         y2 = y_top - lyr.bottom_depth
%         h  = y1 - y2
%         xc = (xL + xR) / 2.0

%     # screen-space paddings (points) so distance from the dashed line is consistent
%         name_pad_pts = 6       # distance below dashed line to the name
%         gap_pts      = 8       # extra gap from name to parameters

%     # 1) Layer name (anchored to the top line, offset downward in points)
%         ax.annotate(
%             lyr.name, xy=(xc, y1), xytext=(0, -name_pad_pts),
%             textcoords='offset points', ha='center', va='top', fontsize=8, color='black'
%     )

%     # 2) Parameters (γ, c, φ) under the name for EVERY layer
%         if show_params and h >= 3:
%             sp = lyr.params
%             lines = []
%             if sp.unit_weight is not None: lines.append(f"γₖ = {sp.unit_weight:g} kN/m³")
%             if sp.unit_weight_sat is not None: lines.append(f"γₛ = {sp.unit_weight_sat:g} kN/m³")
%             if sp.cohesion    is not None: lines.append(f"cᵤ = {sp.cohesion:g} kPa")
%             if sp.phi         is not None: lines.append(f"φₖ = {sp.phi:g}°")
%             if lines:
%                 ax.annotate(
%                     LINE_BREAK.join(lines), xy=(xc, y1),
%                     xytext=(0, -(name_pad_pts + gap_pts)),
%                     textcoords='offset points', ha='center', va='top',
%                     fontsize=8, color='black'
%             )

% def place_force_label(ax, start, vec, text, fs, pad=0.8):
%     """
%     Put a label near the arrow but offset perpendicular to the arrow vector
%     so the text doesn't sit on the wall/layers.
%     """
%     v = np.array(vec, dtype=float)
%     nv = np.linalg.norm(v)
%     if nv == 0:  # fallback
%         ax.text(start[0], start[1], text, fontsize=10, color="black")
%         return
%     vhat = v / nv
%     p = np.array([-vhat[1], vhat[0]])
%     anchor = np.array(start) + v * 0.55 + p * pad
%     ax.text(anchor[0], anchor[1], text, fontsize=10, color="black",
%             ha="center", va="bottom")

% Z       = params["Z"]
% t       = params["t"]
% alpha   = params["alpha_deg"]
% betaL   = params["beta_left_deg"]
% betaR   = params["beta_right_deg"]
% delta   = params["delta_deg"]
% wall_th = params["wall_thickness"]
% fs      = params["font_size"]

% fig, ax = plt.subplots(figsize=params["figsize"])

% # Reference horizontal (dashed) through toe at y=0
% label_horizontal_line(ax, Z, "Ground Surface [+2.5]", x=0.25, fs=8, offset_pts=6)
% label_horizontal_line(ax, 0.0, "Dredge Level [-1.5]",  x=-4, fs=8, offset_pts=6)

% # Water table depth
% ax.plot([0, 4], [Z - params["water_table_depth"], Z - params["water_table_depth"]], linestyle="--", linewidth=1.5, color="black")
% label_horizontal_line(ax, Z - params["water_table_depth"], "GWT [+1.03]", x=0.25, fs=8, offset_pts=6)

% # Water level
% ax.plot([-4, 0], [Z - params["water_level"], Z - params["water_level"]], linestyle="--", linewidth=1.5, color="black")
% label_horizontal_line(ax, Z - params["water_level"], "WL [+0.14]", x=-4, fs=8, offset_pts=6)

% # Wall direction
% theta_wall = 90.0 - alpha
% u = np.array([np.cos(np.deg2rad(theta_wall)), np.sin(np.deg2rad(theta_wall))])
% toe  = np.array([0.0, 0.0])
% top  = toe + u * Z
% base = toe - u * t
% n = np.array([-u[1], u[0]])

% # Wall polygon
% p1 = top  + n * (wall_th/2)
% p2 = base + n * (wall_th/2)
% p3 = base - n * (wall_th/2)
% p4 = top  - n * (wall_th/2)
% ax.plot([p1[0], p2[0], p3[0], p4[0], p1[0]],
%         [p1[1], p2[1], p3[1], p4[1], p1[1]], color="black", linewidth=3)

% len_ground = params['dim_offset']
% left_end = np.array([-len_ground, -np.tan(np.deg2rad(betaL)) * len_ground])
% right_end = top + np.array([len_ground, np.tan(np.deg2rad(betaR)) * len_ground])
% left_attach = toe + n * (wall_th/2)
% ax.plot([left_attach[0], left_end[0]], [left_attach[1], left_end[1]], linewidth=3, color="black")
% ax.plot([top[0], right_end[0]], [top[1], right_end[1]], linewidth=3, color="black")

% draw_layers_right_dashed(
%     ax, top_point=top, block_width=params["dim_offset"], layers=layers,
%     fs=max(12, params["font_size"]-2), show_params=True,
%     min_thk=params["min_layer_thk_for_params"],
%     max_depth=params["Z"] + params["t"]  # plot from right ground down to Z+T
% )

% half_span = max(abs(COMMON_X_MIN - x_wall), abs(COMMON_X_MAX - x_wall))
% ax.set_xlim(x_wall - half_span, x_wall + half_span)
% ax.set_ylim(COMMON_Y_MIN, COMMON_Y_MAX + 1)

% dw = desired_width if 'desired_width' in globals() else 0.6
% dh = desired_height if 'desired_height' in globals() else 0.8
% left = (1.0 - dw) / 2.0
% bottom = (1.0 - dh) / 2.0
% ax.set_position([left, bottom, dw, dh])

% ax.axis("off")
% plt.show()
% \end{lstlisting}

% \section{Vertical effective stress}

% \begin{lstlisting}[language=Python]
% def layer_at(z_mid, layers):
%     for L in layers:
%         if L.top_depth <= z_mid < L.bottom_depth:
%             return L
%     return layers[-1]

% def seg_gamma_eff(L, z1, z2, z_wt, gamma_w=9.81):
%     # segment does not cross GWT (we'll ensure nodes include WT)
%     if z2 <= z_wt:
%         return float(L.params.unit_weight or 0.0)
%     else:
%         if L.params.unit_weight_sat is not None:
%             return float(L.params.unit_weight_sat) - gamma_w
%         return float(L.params.unit_weight or 0.0) - gamma_w

% Z = float(params["Z"])
% t = float(params["t"])
% block_w = float(params["dim_offset"])
% xL_face = float(x_face_left)   # left face (passive side)
% xR_face = float(x_face_right)  # right face (active side)

% z_wt = float(params["water_table_depth"])
% max_depth = float(Z + t)  # toe depth in absolute coordinates

% z_top_L = Z
% z_bot_L = Z + t
% nodes_L = {z_top_L, z_bot_L}
% if z_top_L < z_wt < z_bot_L:
%     nodes_L.add(z_wt)
% for L in layers:
%     if z_top_L <= L.top_depth    <= z_bot_L: nodes_L.add(L.top_depth)
%     if z_top_L <= L.bottom_depth <= z_bot_L: nodes_L.add(L.bottom_depth)
% z_nodes_L = sorted(nodes_L)

% sv_L = [0.0]
% for i in range(1, len(z_nodes_L)):
%     z1, z2 = z_nodes_L[i-1], z_nodes_L[i]
%     Lseg = layer_at((z1+z2)/2.0, layers)
%     gamma = seg_gamma_eff(Lseg, z1, z2, z_wt)
%     sv_L.append(sv_L[-1] + gamma * (z2 - z1))
% z_sv_L = np.array(z_nodes_L)
% sv_L = np.array(sv_L)

% target_L = 0.40 * block_w
% pmax_L = float(np.max(sv_L)) if sv_L.size else 0.0
% scale_L = (target_L / pmax_L) if pmax_L > 1e-12 else 0.0
% y_L = Z - z_sv_L
% x_L = xL_face - sv_L * scale_L

% z_top_R = 0.0
% nodes_R = {z_top_R, min(z_wt, max_depth), max_depth}
% for L in layers:
%     if L.top_depth  <= max_depth: nodes_R.add(max(0.0, L.top_depth))
%     if L.bottom_depth <= max_depth: nodes_R.add(max(0.0, L.bottom_depth))
% z_nodes_R = sorted(nodes_R)

% sv_R = [0.0]
% for i in range(1, len(z_nodes_R)):
%     z1, z2 = z_nodes_R[i-1], z_nodes_R[i]
%     Lseg = layer_at((z1+z2)/2.0, layers)
%     gamma = seg_gamma_eff(Lseg, z1, z2, z_wt)
%     sv_R.append(sv_R[-1] + gamma * (z2 - z1))
% z_sv_R = np.array(z_nodes_R)
% sv_R = np.array(sv_R)

% target_R = 1 * block_w
% pmax_R = float(np.max(sv_R)) if sv_R.size else 0.0
% scale_R = (target_R / pmax_R) if pmax_R > 1e-12 else 0.0
% y_R = Z - z_sv_R
% x_R = xR_face + sv_R * scale_R

% fig, ax = plt.subplots(figsize=params["figsize"])

% try:
%     ax.plot([p1[0], p2[0], p3[0], p4[0], p1[0]],
%             [p1[1], p2[1], p3[1], p4[1], p1[1]], color="black", linewidth=3)
% except NameError:
%     # simple vertical line at x_wall
%     x_wall = 0.0
%     ax.plot([x_wall, x_wall], [Z, Z - t], color="black", linewidth=3)

% left_end  = np.array([-params['dim_offset'], -np.tan(np.deg2rad(params['beta_left_deg'])) * params['dim_offset']])
% right_end = np.array([params['dim_offset'], Z + np.tan(np.deg2rad(params['beta_right_deg'])) * params['dim_offset']])
% toe = np.array([0.0, 0.0])
% top = np.array([0.0, Z])
% ax.plot([toe[0], left_end[0]], [toe[1], left_end[1]], linewidth=3, color="black")
% ax.plot([top[0], right_end[0]], [top[1], right_end[1]], linewidth=3, color="black")

% label_horizontal_line(ax, Z, "GS [+2.5]", x=2.25, fs=8, offset_pts=6)
% label_horizontal_line(ax, 0.0, "DL [-1.5]",  x=-4, fs=8, offset_pts=6)

% ax.plot([0, 4], [Z - params["water_table_depth"], Z - params["water_table_depth"]], linestyle="--", linewidth=1.5, color="black")
% label_horizontal_line(ax, Z - params["water_table_depth"], "GWT [+1.03]", x=2.25, fs=8, offset_pts=6)

% ax.plot([-4, 0], [Z - params["water_level"], Z - params["water_level"]], linestyle="--", linewidth=1.5, color="black")
% label_horizontal_line(ax, Z - params["water_level"], "WL [+0.14]", x=-4, fs=8, offset_pts=6)

% ax.plot(x_L, y_L, color="green", linewidth=2, label="σ′v")
% ax.fill_betweenx(y_L, x_L, xL_face, color="green", alpha=0.25)

% ax.plot(x_R, y_R, color="green", linewidth=2, label="σ′v")
% ax.fill_betweenx(y_R, xR_face, x_R, color="green", alpha=0.25)

% dy = 0.12  # vertical offset for labels
% # simple value labels at key depths (interfaces)
% for z in sorted(set(list(z_sv_L) + list(z_sv_R))):
%     # left val if within left range
%     if z_sv_L.min() <= z <= z_sv_L.max():
%         sv_val = float(np.interp(z, z_sv_L, sv_L))
%         y = Z - z
%         x = xL_face - sv_val * scale_L
%         ax.text(x - 0.03*block_w, y+dy, f"{sv_val:.1f} kN/m²", color="green", fontsize=8, ha="right", va="center")
%     # right val if within right range
%     if z_sv_R.min() <= z <= z_sv_R.max():
%         sv_val = float(np.interp(z, z_sv_R, sv_R))
%         y = Z - z
%         x = xR_face + sv_val * scale_R
%         ax.text(x + 0.03*block_w, y+dy, f"{sv_val:.1f} kN/m²", color="green", fontsize=8, ha="left", va="center")

% draw_layers_right_dashed(
%     ax,
%     top_point=top,
%     block_width=params["dim_offset"],
%     layers=layers,
%     fs=max(12, params["font_size"]-2),
%     show_params=False,
%     min_thk=params["min_layer_thk_for_params"]
% )

% x_wall_center = (xL_face + xR_face) / 2.0
% half_span = max(abs(COMMON_X_MIN - x_wall_center), abs(COMMON_X_MAX - x_wall_center))
% ax.set_xlim(x_wall_center - half_span, x_wall_center + half_span)
% ax.set_ylim(COMMON_Y_MIN, COMMON_Y_MAX + 1)
% dw = desired_width if 'desired_width' in globals() else 0.6
% dh = desired_height if 'desired_height' in globals() else 0.8
% left = (1.0 - dw) / 2.0
% bottom = (1.0 - dh) / 2.0
% ax.set_position([left, bottom, dw, dh])
% ax.axis("off")
% plt.show()

% z_col = "z [m]" if "z [m]" in df_i.columns else "z"
% sv_col = (
%     "σ′v [kN/m²]" if "σ′v [kN/m²]" in df_i.columns
%     else ("σ′v [kPa]" if "σ′v [kPa]" in df_i.columns else "sigma_v")
% )

% max_depth = float(Z + t)
% z_wt = float(params["water_table_depth"])

% df_right = df_i[[z_col, sv_col]].copy()
% df_right = df_right[df_right[z_col] <= max_depth].sort_values(z_col).reset_index(drop=True)

% if "df_sigma_left" in globals():
%     df_left = df_sigma_left.copy().sort_values(z_col).reset_index(drop=True)
% else:
%     df_left = pd.DataFrame({z_col: z_sv_L, "σ′v_left [kN/m²]": sv_L}).sort_values(z_col).reset_index(drop=True)

% left_sv_col = next(c for c in df_left.columns if c != z_col)
% right_z = df_right[z_col].to_numpy()
% right_sv = df_right[sv_col].to_numpy()
% left_z = df_left[z_col].to_numpy()
% left_sv = df_left[left_sv_col].to_numpy()

% union_z = np.unique(np.concatenate([right_z, left_z, [z_wt] if (0 <= z_wt <= max_depth) else []]))
% union_z = np.sort(union_z)

% right_interp = np.interp(union_z, right_z, right_sv)
% left_interp = np.interp(union_z, left_z, left_sv)

% df_both = pd.DataFrame({
%     "z [m]": union_z,
%     "σ′v_left [kN/m²]": left_interp,
%     "σ′v_right [kN/m²]": right_interp
% })

% from IPython.display import display
% display(
%     df_both.style.format({"z [m]": "{:.2f}", "σ′v_left [kN/m²]": "{:.2f}", "σ′v_right [kN/m²]": "{:.2f}"})
% )
% \end{lstlisting}

\section{Earth pressure and force}

\begin{lstlisting}[language=Python]
@dataclass
class SoilParams:
    unit_weight: Optional[float] = None    # γ [kN/m³]
    cohesion: Optional[float] = None       # c [kPa]
    phi: Optional[float] = None            # φ [°]
    delta: Optional[float] = None          # δ [°]
    k_subgrade: Optional[float] = None     # k [kN/m³]
    modulus_E: Optional[float] = None      # E [MPa]
    permeability_k: Optional[float] = None # kperm [m/s]
    unit_weight_sat: Optional[float] = None  # γ_sat [kN/m³]

@dataclass
class Layer:
    name: str
    top_depth: float         # depth from right ground surface, positive downward [m]
    bottom_depth: float      # depth from right ground surface, positive downward [m]
    params: SoilParams
    color: str = "#dddddd"

layers: List[Layer] = [
    Layer("Fill",             0.0,   2.0,  SoilParams(unit_weight=12.0, cohesion=20, phi=15.0, unit_weight_sat=12.0)),
    Layer("Fine–Medium Sand", 2.0,   7.0,  SoilParams(unit_weight=17.0, cohesion=0,  phi=30,   unit_weight_sat=19.0)),
    Layer("Clay",             7.0,  10.0,  SoilParams(unit_weight=14.0, cohesion=25, phi=17.5, unit_weight_sat=14.0)),
    Layer("Clayey Sand",     10.0,  15.0,  SoilParams(unit_weight=18.0, cohesion=0,  phi=25,   unit_weight_sat=20.0)),
    Layer("Clay",            15.0,  16.0,  SoilParams(unit_weight=14.0, cohesion=25, phi=17.5, unit_weight_sat=14.0)),
    Layer("Clayey Sand",     16.0,  17.5,  SoilParams(unit_weight=18.0, cohesion=0,  phi=25,   unit_weight_sat=20.0)),
    Layer("Medium Sand",     17.5,  32.5,  SoilParams(unit_weight=18.0, cohesion=0,  phi=32.5, unit_weight_sat=20.0)),
]

def label_horizontal_line(ax, y, text, x=0.0, fs=8, offset_pts=6):
    ax.annotate(text, xy=(x, y), xytext=(0, offset_pts),
                textcoords='offset points', ha='left', va='bottom', fontsize=fs, color='black')

def draw_layers_right_dashed(ax, top_point, block_width, layers,
                             fs=8, show_params=True, min_thk=0.5,
                             dash_pattern=(6, 4)):
    x0, y_top = top_point
    xL = x0
    xR = xL + block_width
    boundaries = []
    for lyr in layers:
        boundaries += [y_top - lyr.top_depth, y_top - lyr.bottom_depth]
    boundaries = sorted(list({round(b, 6) for b in boundaries}))
    for y in boundaries:
        ax.plot([xL, xR], [y, y], linestyle=(0, dash_pattern), linewidth=1.2, color="black")
    if not show_params:
        return
    for lyr in layers:
        y1 = y_top - lyr.top_depth
        y2 = y_top - lyr.bottom_depth
        h  = y1 - y2
        if h < min_thk: 
            continue
        xc = (xL + xR) / 2.0
        sp = lyr.params
        lines = []
        if sp.unit_weight is not None:     lines.append(f"γ = {sp.unit_weight:g} kN/m³")
        if sp.unit_weight_sat is not None: lines.append(f"γ_sat = {sp.unit_weight_sat:g} kN/m³")
        if sp.cohesion    is not None:     lines.append(f"c = {sp.cohesion:g} kPa")
        if sp.phi         is not None:     lines.append(f"φ = {sp.phi:g}°")
        if lines:
            ax.annotate("\n".join(lines), xy=(xc, y1),
                        xytext=(0, -12), textcoords='offset points',
                        ha='center', va='top', fontsize=6, color='black')

def compute_active_pressures_with_interfaces(
    layers, water_table_depth, gamma_w=9.81, surcharge_q=0.0
):
    """
    Returns piecewise-active profile and an interface dataframe (with GWT included).
    df_i columns include:
      - "z [m]", "σ′v [kN/m²]", "Ka↑", "Ka↓",
        "p↑ = Ka↑·σ′v [kN/m²]" (just above/bottom), "p↓ = Ka↓·σ′v [kN/m²]" (just below/top)
    """
    def Ka_of(phi_deg: float) -> float:
        if phi_deg is None: return 1.0
        a = np.deg2rad(45.0 - 0.5*phi_deg)
        return np.tan(a)**2

    z_wt = float(water_table_depth)

    # nodes for piecewise integration (include GWT)
    nodes = {0.0, z_wt}
    for L in layers:
        nodes.add(L.top_depth); nodes.add(L.bottom_depth)
    nodes = sorted(x for x in nodes if x >= 0.0)

    def layer_at(z_mid):
        for L in layers:
            if L.top_depth <= z_mid < L.bottom_depth:
                return L
        return layers[-1]

    def gamma_eff(L, z_top, z_bot):
        # segment will not cross GWT, nodes guarantee this
        if z_bot <= z_wt:  # above GWT
            return float(L.params.unit_weight or 0.0)
        else:              # below GWT
            if L.params.unit_weight_sat is not None:
                return float(L.params.unit_weight_sat) - gamma_w
            return float(L.params.unit_weight or 0.0) - gamma_w

    # Effective vertical stress at nodes (independent of Ka)
    sigma_v_at_node = {0.0: surcharge_q}
    for k in range(1, len(nodes)):
        zt, zb = nodes[k-1], nodes[k]
        Lseg = layer_at((zt+zb)/2.0)
        sigma_v_at_node[zb] = sigma_v_at_node[zt] + gamma_eff(Lseg, zt, zb) * (zb - zt)

    # Active lateral pressure accumulation over segments
    depths = [0.0]; pvals = [0.0]
    for k in range(1, len(nodes)):
        zt, zb = nodes[k-1], nodes[k]
        Lseg  = layer_at((zt+zb)/2.0)
        Ka    = Ka_of(Lseg.params.phi or 0.0)
        gamma = gamma_eff(Lseg, zt, zb)
        pvals.append(pvals[-1] + Ka * gamma * (zb - zt))
        depths.append(zb)

    # Interfaces (INCLUDE GWT explicitly so the jump is correct at z = z_wt)
    interfaces = []
    eps = 1e-9
    layer_bounds = sorted(
        ({L.bottom_depth for L in layers}
         | {L.top_depth for L in layers}
         | {z_wt})  # <— include water table as an interface depth
    )
    for zb in layer_bounds:
        if zb < 0.0:
            continue
        # σ′v at boundary
        if zb in sigma_v_at_node:
            sv = sigma_v_at_node[zb]
        else:
            # interpolate between neighbor nodes
            j = np.searchsorted(nodes, zb)
            z0, z1 = nodes[j-1], nodes[j]
            sv0, sv1 = sigma_v_at_node[z0], sigma_v_at_node[z1]
            sv = sv0 + (sv1 - sv0) * (zb - z0) / (z1 - z0)

        Labove = layer_at(max(zb - eps, 0.0))
        Lbelow = layer_at(zb + eps)
        Ka_above = Ka_of(Labove.params.phi or 0.0)
        Ka_below = Ka_of(Lbelow.params.phi or 0.0)

        interfaces.append(dict(
            z=zb,
            sigma_v=sv,
            Ka_above=Ka_above,
            Ka_below=Ka_below,
            p_from_above=Ka_above * sv,  # p just above/bottom (top side of interface)
            p_from_below=Ka_below * sv,  # p just below/top (bottom side of interface)
        ))

    df_i = pd.DataFrame(interfaces).sort_values("z").reset_index(drop=True)
    df_i = df_i.rename(columns={
        "z": "z [m]",
        "sigma_v": "σ′v [kN/m²]",
        "Ka_above": "Ka↑",
        "Ka_below": "Ka↓",
        "p_from_above": "p↑ = Ka↑·σ′v [kN/m²]",
        "p_from_below": "p↓ = Ka↓·σ′v [kN/m²]",
    })
    return np.array(depths), np.array(pvals), interfaces, df_i

def compute_passive_pressures_left_with_interfaces(
    layers, Z, t, water_table_depth, gamma_w=9.81, surcharge_q=0.0
):
    def Kp_of(phi_deg: Optional[float]):
        a = np.deg2rad(45.0 + 0.5*(phi_deg or 0.0))
        return np.tan(a)**2

    z_top = float(Z)
    z_toe = float(Z + t)
    z_wt  = float(water_table_depth)

    # nodes along left side (from dredge Z down to toe Z+t), include GWT if inside
    nodes = {z_top, z_toe}
    if z_top < z_wt < z_toe: nodes.add(z_wt)
    for L in layers:
        if z_top <= L.top_depth    <= z_toe: nodes.add(L.top_depth)
        if z_top <= L.bottom_depth <= z_toe: nodes.add(L.bottom_depth)
    nodes = sorted(nodes)

    def layer_at(z_mid):
        for L in layers:
            if L.top_depth <= z_mid < L.bottom_depth:
                return L
        return layers[-1]

    def gamma_eff(L, z1, z2):
        # segment won't cross GWT due to nodes
        if z2 <= z_wt:  # above GWT (shallower)
            return float(L.params.unit_weight or 0.0)
        else:           # below GWT
            if L.params.unit_weight_sat is not None:
                return float(L.params.unit_weight_sat) - gamma_w
            return float(L.params.unit_weight or 0.0) - gamma_w

    # Effective vertical stress at nodes (from top Z downward)
    sigma = [surcharge_q]
    for i in range(1, len(nodes)):
        z1, z2 = nodes[i-1], nodes[i]
        Lseg = layer_at((z1+z2)/2.0)
        sigma.append(sigma[-1] + gamma_eff(Lseg, z1, z2) * (z2 - z1))
    sigma = np.array(sigma)

    # Build interface table in same spirit as "active"
    recs = []
    eps = 1e-9
    for zb in nodes:
        sv = float(np.interp(zb, np.array(nodes), sigma))
        Labove = layer_at(max(zb - eps, z_top))
        Lbelow = layer_at(min(zb + eps, z_toe - eps))
        Kp_up  = Kp_of(Labove.params.phi)
        Kp_dn  = Kp_of(Lbelow.params.phi)
        recs.append(dict(
            z=zb, sigma_v_left=sv,
            Kp_up=Kp_up, Kp_dn=Kp_dn,
            p_up=Kp_up*sv, p_dn=Kp_dn*sv
        ))

    df = pd.DataFrame(recs).sort_values("z").reset_index(drop=True)
    df = df.rename(columns={
        "z": "z [m]",
        "sigma_v_left": "σ′v_left [kN/m²]",
        "Kp_up": "Kp↑",
        "Kp_dn": "Kp↓",
        "p_up": "p↑ = Kp↑·σ′v [kN/m²]",
        "p_dn": "p↓ = Kp↓·σ′v [kN/m²]",
    })
    return np.array(nodes), sigma, df

Z       = float(params["Z"])
t       = float(params["t"])
alpha   = float(params["alpha_deg"])
betaL   = float(params["beta_left_deg"])
betaR   = float(params["beta_right_deg"])
wall_th = float(params["wall_thickness"])
fs      = int(params["font_size"])
block_w = params["dim_offset"]

fig, ax = plt.subplots(figsize=params["figsize"])

label_horizontal_line(ax, Z, "GS [+2.5]", x=2.25, fs=8, offset_pts=6)
label_horizontal_line(ax, 0.0, "DL [-1.5]",  x=-4, fs=8, offset_pts=6)

ax.plot([0, 4], [Z - params["water_table_depth"], Z - params["water_table_depth"]], linestyle="--", linewidth=1.5, color="black")
label_horizontal_line(ax, Z - params["water_table_depth"], "GWT [+1.03]", x=2.25, fs=8, offset_pts=6)

ax.plot([-4, 0], [Z - params["water_level"], Z - params["water_level"]], linestyle="--", linewidth=1.5, color="black")
label_horizontal_line(ax, Z - params["water_level"], "WL [+0.14]", x=-4, fs=8, offset_pts=6)

theta_wall = 90.0 - alpha
uvec = np.array([np.cos(np.deg2rad(theta_wall)), np.sin(np.deg2rad(theta_wall))])
toe  = np.array([0.0, 0.0])
top  = toe + uvec * Z
base = toe - uvec * t
nvec = np.array([-uvec[1], uvec[0]])

p1 = top  + nvec * (wall_th/2)
p2 = base + nvec * (wall_th/2)
p3 = base - nvec * (wall_th/2)
p4 = top  - nvec * (wall_th/2)
ax.plot([p1[0], p2[0], p3[0], p4[0], p1[0]],
        [p1[1], p2[1], p3[1], p4[1], p1[1]], color="black", linewidth=3)

left_end  = np.array([-block_w, -np.tan(np.deg2rad(betaL)) * block_w])
right_end = top + np.array([block_w, np.tan(np.deg2rad(betaR)) * block_w])
ax.plot([toe[0], left_end[0]],  [toe[1], left_end[1]],  linewidth=3, color="black")
ax.plot([top[0], right_end[0]], [top[1], right_end[1]], linewidth=3, color="black")

draw_layers_right_dashed(
    ax, top_point=top, block_width=block_w, layers=layers,
    fs=max(12, params["font_size"]-2), show_params=False,
    min_thk=params["min_layer_thk_for_params"]
)

x_face_left  = min(p1[0], p2[0], p3[0], p4[0])
x_face_right = max(p1[0], p2[0], p3[0], p4[0])
z_top = Z
z_toe = Z + t

depths, pa, interfaces, df_i = compute_active_pressures_with_interfaces(
    layers, water_table_depth=z_wt, gamma_w=9.81
)
z_col  = "z [m]" if "z [m]" in df_i.columns else "z"
sv_col = "σ′v [kN/m²]" if "σ′v [kN/m²]" in df_i.columns else "sigma_v"
p_up_c = "p↑ = Ka↑·σ′v [kN/m²]" if "p↑ = Ka↑·σ′v [kN/m²]" in df_i.columns else "p_from_above"
p_dn_c = "p↓ = Ka↓·σ′v [kN/m²]" if "p↓ = Ka↓·σ′v [kN/m²]" in df_i.columns else "p_from_below"

rows_df = df_i[df_i[z_col] <= z_toe].copy()
if not np.isclose(rows_df[z_col].max(), z_toe):
    sv_toe = float(np.interp(z_toe, df_i[z_col].to_numpy(), df_i[sv_col].to_numpy()))
    def _layer_at_right(z):
        for L in layers:
            if L.top_depth <= z < L.bottom_depth: return L
        return layers[-1]
    Ka_toe = np.tan(np.deg2rad(45.0 - 0.5*(_layer_at_right(z_toe-1e-6).params.phi or 0.0)))**2
    p_toe = Ka_toe * sv_toe
    rows_df = pd.concat([rows_df, pd.DataFrame([{z_col: z_toe, p_up_c: p_toe, p_dn_c: p_toe}])],
                        ignore_index=True)
rows_df = rows_df.sort_values(z_col).reset_index(drop=True)
rows_active = rows_df.to_dict("records")

_, _, df_pass = compute_passive_pressures_left_with_interfaces(
    layers, Z=Z, t=t, water_table_depth=z_wt, gamma_w=9.81, surcharge_q=0.0
)
p_up_col = "p↑ = Kp↑·σ′v [kN/m²]"
p_dn_col = "p↓ = Kp↓·σ′v [kN/m²]"
df_pass_clip = df_pass[df_pass["z [m]"] <= z_toe].copy()
rows_p = df_pass_clip.sort_values("z [m]").to_dict("records")

pmax_active  = float(max(rows_df[p_up_c].max(),  rows_df[p_dn_c].max()))
pmax_passive = float(max(df_pass_clip[p_up_col].max(), df_pass_clip[p_dn_col].max()))
target = 0.40 * block_w
scale_both = target / max(pmax_active, pmax_passive, 1e-12)

x_ptsR, y_ptsR = [], []
if rows_active:
    x_ptsR.append(x_face_right + float(rows_active[0][p_dn_c]) * scale_both)
    y_ptsR.append(Z - float(rows_active[0][z_col]))
for i in range(len(rows_active) - 1):
    zb    = float(rows_active[i+1][z_col])
    p_end = float(rows_active[i+1][p_up_c])
    x1 = x_face_right + p_end * scale_both; y1 = Z - zb
    x_ptsR.append(x1); y_ptsR.append(y1)
    p_next = float(rows_active[i+1][p_dn_c])
    x_next = x_face_right + p_next * scale_both
    if abs(x1 - x_next) > 1e-12:
        x_ptsR.append(x_next); y_ptsR.append(y1)
xR, yR = np.array(x_ptsR), np.array(y_ptsR)
ax.plot(xR, yR, color="red", lw=2, label="Active Earth Pressure")
ax.fill_betweenx(yR, x_face_right, xR, color="red", alpha=0.30)

x_ptsL, y_ptsL = [], []
if rows_p:
    x_ptsL.append(x_face_left - float(rows_p[0][p_dn_col]) * scale_both)
    y_ptsL.append(Z - float(rows_p[0]["z [m]"]))
for i in range(len(rows_p) - 1):
    zb    = float(rows_p[i+1]["z [m]"])
    p_end = float(rows_p[i+1][p_up_col])
    x1 = x_face_left - p_end * scale_both; y1 = Z - zb
    x_ptsL.append(x1); y_ptsL.append(y1)
    p_next = float(rows_p[i+1][p_dn_col])
    x_next = x_face_left - p_next * scale_both
    if abs(x1 - x_next) > 1e-12:
        x_ptsL.append(x_next); y_ptsL.append(y1)
xL, yL = np.array(x_ptsL), np.array(y_ptsL)
ax.plot(xL, yL, color="navy", lw=2, label="Passive Earth Pressure")
ax.fill_betweenx(yL, xL, x_face_left, color="navy", alpha=0.30)

def _decompose_forces(rows, z_key, p_top_key, p_bot_key, z_start, z_end):
    """Split each [z_i,z_{i+1}] trapezoid into rectangle + triangle components."""
    segs = sorted([r for r in rows if z_start <= float(r[z_key]) <= z_end],
                  key=lambda r: float(r[z_key]))
    out = []
    for i in range(len(segs) - 1):
        zt = float(segs[i][z_key]); zb = float(segs[i+1][z_key]); H = zb - zt
        if H <= 0: 
            continue
        pt = float(segs[i][p_top_key])     # p just below the top interface
        pb = float(segs[i+1][p_bot_key])   # p just above the bottom interface

        pmin = min(pt, pb)
        dp   = pb - pt

        # Rectangle component
        F_rect  = pmin * H
        if F_rect > 1e-12:
            out.append(dict(F=F_rect, zc=zt + 0.5*H, kind="rect", i=i))

        # Triangle component
        F_tri   = 0.5 * abs(dp) * H
        if F_tri > 1e-12:
            zc_tri = zt + (2.0/3.0*H if dp > 0 else 1.0/3.0*H)
            out.append(dict(F=F_tri, zc=zc_tri, kind="tri", i=i))
    return out

active_comps  = _decompose_forces(rows_active, z_key=z_col,
                                  p_top_key=p_dn_c, p_bot_key=p_up_c,
                                  z_start=0.0, z_end=z_toe)

passive_comps = _decompose_forces(rows_p, z_key="z [m]",
                                  p_top_key=p_dn_col, p_bot_key=p_up_col,
                                  z_start=z_top, z_end=z_toe)

F_ref = max([c["F"] for c in (active_comps + passive_comps)] + [1e-12])
arrow_span   = 1 * block_w
arrow_scaleF = arrow_span / F_ref

def _draw_force_components_toward_wall(ax, comps, x_wall, to_wall_sign, color, prefix):
    """
    Draw each component as a horizontal arrow with the **head at the centroid** (point of action),
    pointing **into the wall**.
      - to_wall_sign: +1 → wall is to the RIGHT of soil (passive/left side)  → arrow points +x
                      -1 → wall is to the LEFT  of soil (active/right side)  → arrow points -x
    Uses annotate() so the arrow HEAD is at xy (centroid) with a smaller head.
    """
    comps = sorted(comps, key=lambda c: c["zc"])
    for k, c in enumerate(comps, start=1):
        L  = c["F"] * arrow_scaleF               # arrow length to show magnitude
        y  = Z - c["zc"]                         # centroid elevation

        # Draw a small tick at the PoA on the wall
        ax.plot([x_wall - 0.06, x_wall + 0.06], [y, y], color=color, lw=1.4)

        # Arrow HEAD at centroid on the wall; tail away from wall by length L
        # Smaller arrowhead via mutation_scale
        if to_wall_sign > 0:
            # passive: head at (x_wall, y), tail at (x_wall - L, y)
            xy     = (x_wall, y)
            xytext = (x_wall - L, y)
            ha_txt = "right"
            x_lab  = x_wall - L - 0.03*block_w
        else:
            # active: head at (x_wall, y), tail at (x_wall + L, y)
            xy     = (x_wall, y)
            xytext = (x_wall + L, y)
            ha_txt = "left"
            x_lab  = x_wall + L + 0.03*block_w

        ax.annotate(
            "", xy=xy, xytext=xytext,
            arrowprops=dict(
                arrowstyle="-|>",        # filled head at xy
                lw=2.0,
                color=color,
                mutation_scale=8.0       # <<< SMALLER HEAD
            )
        )

        # label near the tail side (away from wall) to keep clear of the head/PoA
        ax.text(
            x_lab, y + (0.06 if (k % 2) else -0.06),
            f"{prefix}{k} ({c['kind']}): {c['F']:.2f} kN/m",
            fontsize=7.5, ha=ha_txt, va="center", color=color
        )

_draw_force_components_toward_wall(ax, active_comps,  x_wall=x_face_right, to_wall_sign=-1, color="red",  prefix="Fₐ")
_draw_force_components_toward_wall(ax, passive_comps, x_wall=x_face_left,  to_wall_sign=+1, color="navy", prefix="Fₚ")

half_span = max(abs(COMMON_X_MIN - x_wall), abs(COMMON_X_MAX - x_wall))
ax.set_xlim(x_wall - half_span, x_wall + half_span)
ax.set_ylim(COMMON_Y_MIN, COMMON_Y_MAX + 1)

# position the axes in the middle of the figure canvas
dw = desired_width if 'desired_width' in globals() else 0.6
dh = desired_height if 'desired_height' in globals() else 0.8
left = (1.0 - dw) / 2.0
bottom = (1.0 - dh) / 2.0
ax.set_position([left, bottom, dw, dh])

ax.axis("off")
plt.show()
\end{lstlisting}

% \section{Hydrostatic pressure and force}

% \begin{lstlisting}[language=Python]
% def hydro_triangle_resultant(z_top: float, z_bot: float, gamma_w: float = 9.81):
%     """
%     Resultant and centroid for triangular hydrostatic pressure u(z)=γw(z - z_top)
%     acting over [z_top, z_bot] on the RIGHT face of the wall.
%     Returns (F, zc) with F in kN/m and zc in m (depth measured downward).
%     """
%     z_top = float(z_top); z_bot = float(z_bot)
%     if z_bot <= z_top:
%         return 0.0, 0.5*(z_top + z_bot)
%     H  = z_bot - z_top
%     F  = 0.5 * gamma_w * H * H        # area of triangle
%     zc = z_top + (2.0/3.0) * H        # 1/3 above bottom
%     return F, zc

% fig, (axL, axR, axC) = plt.subplots(1, 3, figsize=params["figsize"], sharey=True)
% plt.subplots_adjust(wspace=0.02)

% Z = params["Z"]
% t = params["t"]
% wall_th = params["wall_thickness"]
% theta_wall = 90.0 - params["alpha_deg"]
% u = np.array([np.cos(np.deg2rad(theta_wall)), np.sin(np.deg2rad(theta_wall))])
% toe  = np.array([0.0, 0.0])
% top  = toe + u * Z
% base = toe - u * t
% n = np.array([-u[1], u[0]])

% p1 = top  + n * (wall_th/2)
% p2 = base + n * (wall_th/2)
% p3 = base - n * (wall_th/2)
% p4 = top  - n * (wall_th/2)

% x_face_left  = min(p1[0], p2[0], p3[0], p4[0])
% x_face_right = max(p1[0], p2[0], p3[0], p4[0])

% gamma_w   = 9.81
% z_top_L   = float(params["water_level"])
% z_top_R   = float(params["water_table_depth"])
% z_toe     = float(Z + t)

% pR_max = gamma_w * max(0.0, z_toe - z_top_R)
% pL_max = gamma_w * max(0.0, z_toe - z_top_L)
% p_max  = max(pR_max, pL_max, 1e-12)

% block_w  = float(params["dim_offset"])
% target_w = 3 * block_w
% hydro_scale = target_w / p_max

% # helper lists of z marks (interfaces already available as z_interfaces)
% z_col = "z [m]" if "z [m]" in df_i.columns else "z"
% z_interfaces = df_i[z_col].to_numpy(dtype=float)

% ax = axL
% ax.plot([0, 4], [Z - params["water_table_depth"], Z - params["water_table_depth"]], linestyle="--", linewidth=1.0, color="black")
% ax.plot([-4, 0], [Z - params["water_level"], Z - params["water_level"]], linestyle="--", linewidth=1.0, color="black")

% ax.plot([p1[0], p2[0], p3[0], p4[0], p1[0]],
%     [p1[1], p2[1], p3[1], p4[1], p1[1]], color="black", linewidth=3)
% len_ground = params['dim_offset']
% left_end  = np.array([-len_ground, -np.tan(np.deg2rad(params["beta_left_deg"])) * len_ground])
% right_end = top + np.array([len_ground, np.tan(np.deg2rad(params["beta_right_deg"])) * len_ground])
% ax.plot([toe[0], left_end[0]], [toe[1], left_end[1]], linewidth=3, color="black")
% ax.plot([top[0], right_end[0]], [top[1], right_end[1]], linewidth=3, color="black")

% draw_layers_right_dashed(
%     ax,
%     top_point=top,
%     block_width=params["dim_offset"],
%     layers=layers,
%     fs=max(12, params["font_size"]-2),
%     show_params=False,
%     min_thk=params["min_layer_thk_for_params"]
% )

% # draw hydro wedges (both sides) on axL
% if z_top_R < z_toe:
%     yR = np.array([Z - z_top_R, Z - z_toe], float)
%     pR = np.array([0.0, gamma_w * (z_toe - z_top_R)], float)
%     xR = x_face_right + pR * hydro_scale
%     ax.plot(xR, yR, lw=2, color="blue")
%     ax.fill_betweenx(yR, x_face_right, xR, color="blue", alpha=0.30)

% if z_top_L < z_toe:
%     yL = np.array([Z - z_top_L, Z - z_toe], float)
%     pL = np.array([0.0, gamma_w * (z_toe - z_top_L)], float)
%     xL = x_face_left - pL * hydro_scale
%     ax.plot(xL, yL, lw=2, color="blue")
%     ax.fill_betweenx(yL, xL, x_face_left, color="blue", alpha=0.30)

% # labels for hydro pressures (both sides) at important z marks
% def under_water_right(z):  return z > z_top_R and z <= z_toe
% def under_water_left(z):   return z > z_top_L and z <= z_toe

% z_marks = {z_toe}
% if z_top_R < z_toe: z_marks.add(z_top_R)
% if z_top_L < z_toe: z_marks.add(z_top_L)
% z_marks.update([z for z in z_interfaces if under_water_left(z) or under_water_right(z)])
% z_marks = sorted(z_marks)

% def u_right(z): return gamma_w * max(0.0, z - z_top_R)
% def u_left(z):  return gamma_w * max(0.0, z - z_top_L)

% x_min_needed = np.inf
% x_max_needed = -np.inf
% v_off = 0.18

% for i, z in enumerate(z_marks):
%     y = Z - z

%     # Right label (if submerged on right)
%     if z >= z_top_R:
%         uR = u_right(z)
%         xR_tip = x_face_right + uR * hydro_scale
%         xR_txt = xR_tip + 0.03 * target_w
%         ax.text(xR_txt, y + (v_off if i % 2 == 0 else -v_off),
%             f"{uR:.1f} kN/m²", fontsize=8, ha="left", va="center", color="blue")
%         x_max_needed = max(x_max_needed, xR_txt)

%     # Left label (if submerged on left)
%     if z >= z_top_L:
%         uL = u_left(z)
%         xL_tip = x_face_left - uL * hydro_scale
%         xL_txt = xL_tip - 0.03 * target_w
%         ax.text(xL_txt, y + (v_off if i % 2 == 0 else -v_off),
%             f"{uL:.1f} kN/m²", fontsize=8, ha="right", va="center", color="blue")
%         x_min_needed = min(x_min_needed, xL_txt)

% # adjust x-limits to show labels (centered on wall)
% xlo, xhi = ax.get_xlim()
% pad = 0.05 * (xhi - xlo if xhi > xlo else 10.0)
% if np.isfinite(x_min_needed): xlo = min(xlo, x_min_needed - pad)
% if np.isfinite(x_max_needed): xhi = max(xhi, x_max_needed + pad)

% half_span = max(abs(COMMON_X_MIN - x_wall), abs(COMMON_X_MAX - x_wall))
% ax.set_xlim(x_wall - half_span, x_wall + half_span)
% ax.set_ylim(COMMON_Y_MIN, COMMON_Y_MAX + 1)
% ax.axis("off")

% ax = axR
% label_horizontal_line(ax, Z, "GS [+2.5]", x=0.25, fs=8, offset_pts=6)
% label_horizontal_line(ax, 0.0, "DL [-1.5]",  x=-4, fs=8, offset_pts=6)

% ax.plot([0, 4], [Z - params["water_table_depth"], Z - params["water_table_depth"]], linestyle="--", linewidth=1.5, color="black")
% label_horizontal_line(ax, Z - params["water_table_depth"], "GWT [+1.03]", x=0.25, fs=8, offset_pts=6)

% ax.plot([-4, 0], [Z - params["water_level"], Z - params["water_level"]], linestyle="--", linewidth=1.5, color="black")
% label_horizontal_line(ax, Z - params["water_level"], "WL [+0.14]", x=-4, fs=8, offset_pts=6)

% ax.plot([p1[0], p2[0], p3[0], p4[0], p1[0]],
%     [p1[1], p2[1], p3[1], p4[1], p1[1]], color="black", linewidth=3)
% ax.plot([toe[0], left_end[0]], [toe[1], left_end[1]], linewidth=3, color="black")
% ax.plot([top[0], right_end[0]], [top[1], right_end[1]], linewidth=3, color="black")

% draw_layers_right_dashed(
%     ax,
%     top_point=top,
%     block_width=params["dim_offset"],
%     layers=layers,
%     fs=max(12, params["font_size"]-2),
%     show_params=False,
%     min_thk=params["min_layer_thk_for_params"]
% )

% # compute excess values at interface marks
% z_marks = {z_toe}
% if z_top_R < z_toe: z_marks.add(z_top_R)
% if z_top_L < z_toe: z_marks.add(z_top_L)
% z_marks.update([z for z in z_interfaces if (z > z_top_L and z <= z_toe) or (z > z_top_R and z <= z_toe)])
% z_marks = sorted(z_marks)

% z_plot = np.array(sorted(z_marks), dtype=float)
% y_plot = Z - z_plot
% uR_vals = gamma_w * np.maximum(0.0, z_plot - z_top_R)
% uL_vals = gamma_w * np.maximum(0.0, z_plot - z_top_L)
% uN_vals = uR_vals - uL_vals  # excess R - L

% # group contiguous runs where uN positive/negative
% def contiguous_runs(mask):
%     runs = []
%     run = None
%     for i, m in enumerate(mask):
%         if m:
%             if run is None:
%                 run = []
%             run.append(i)
%         else:
%             if run is not None:
%                 runs.append(run)
%                 run = None
%     if run is not None:
%         runs.append(run)
%     return runs

% pos_mask = uN_vals > 0
% neg_mask = uN_vals < 0

% x_max_needed = -np.inf
% x_min_needed = np.inf

% # plot positive net (to RIGHT)
% for run in contiguous_runs(pos_mask):
%     idx = np.array(run)
%     if idx.size == 0:
%         continue
%     # include the immediate previous point if it exists and is zero so the wedge anchors at GWT
%     if idx[0] > 0 and np.isclose(uN_vals[idx[0]-1], 0.0):
%         idx = np.concatenate(([idx[0]-1], idx))
%     if idx.size < 2:
%         continue
%     y_seg = y_plot[idx]
%     x_seg = x_face_right + uN_vals[idx] * hydro_scale
%     ax.plot(x_seg, y_seg, lw=2, color="blue")
%     ax.fill_betweenx(y_seg, x_face_right, x_seg, color="blue", alpha=0.30)

% # plot negative net (to LEFT)
% for run in contiguous_runs(neg_mask):
%     idx = np.array(run)
%     if idx.size == 0:
%         continue
%     # include the immediate previous point if it exists and is zero so the wedge anchors at GWT
%     if idx[0] > 0 and np.isclose(uN_vals[idx[0]-1], 0.0):
%         idx = np.concatenate(([idx[0]-1], idx))
%     if idx.size < 2:
%         continue
%     y_seg = y_plot[idx]
%     x_seg = x_face_left - (-uN_vals[idx]) * hydro_scale
%     ax.plot(x_seg, y_seg, lw=2, color="blue")
%     ax.fill_betweenx(y_seg, x_seg, x_face_left, color="blue", alpha=0.30)

% # labels for excess at key levels
% v_off = 0.18
% for i, z in enumerate(z_plot):
%     y = Z - z
%     uN = uN_vals[i]
%     if np.isclose(uN, 0.0):
%         continue
%     if uN > 0:
%         x_tip = x_face_right + uN * hydro_scale
%         x_txt = x_tip + 0.03 * target_w
%         ha = "left"
%     else:
%         x_tip = x_face_left - (-uN) * hydro_scale
%         x_txt = x_tip - 0.03 * target_w
%         ha = "right"
%     ax.text(x_txt, y + (v_off if i % 2 == 0 else -v_off),
%         f"{uN:.1f} kN/m²", fontsize=8, ha=ha, va="center", color="blue")
%     x_max_needed = max(x_max_needed, x_txt)
%     x_min_needed = min(x_min_needed, x_txt)

% ax.set_xlim(x_wall - half_span, x_wall + half_span)
% ax.set_ylim(COMMON_Y_MIN, COMMON_Y_MAX + 1)
% ax.axis("off")

% ax = axC
% ax.plot([p1[0], p2[0], p3[0], p4[0], p1[0]],
%         [p1[1], p2[1], p3[1], p4[1], p1[1]], color="black", linewidth=3)

% FL, zcL = (0.0, None)
% FR, zcR = (0.0, None)
% if z_top_L < z_toe:
%     FL, zcL = hydro_triangle_resultant(z_top_L, z_toe, gamma_w)
% if z_top_R < z_toe:
%     FR, zcR = hydro_triangle_resultant(z_top_R, z_toe, gamma_w)

% # Net resultant (positive = to right)
% Fnet = FR - FL
% zc_net = None
% if abs(Fnet) > 1e-12:
%     # take sign into account: right is positive x, left acts opposite
%     # net centroid measured from top: (FR*zcR - FL*zcL) / (FR - FL)
%     zc_net = (FR * zcR - FL * zcL) / (FR - FL)

% # arrow plotting positions
% off = 2.25 * block_w
% if FL > 0 and zcL is not None:
%     yL = Z - zcL
%     x_start = x_face_left - off
%     x_end   = x_face_left
%     ax.annotate("", xy=(x_end, yL), xytext=(x_start, yL),
%                 arrowprops=dict(arrowstyle="-|>", lw=2.0, color="blue", mutation_scale=12))
%     ax.text(x_start - 0.03*block_w, yL, f"FL: {FL:.2f} kN/m",
%             fontsize=8, ha="right", va="center", color="blue")

% if FR > 0 and zcR is not None:
%     yR = Z - zcR
%     x_start = x_face_right + off
%     x_end   = x_face_right
%     ax.annotate("", xy=(x_end, yR), xytext=(x_start, yR),
%                 arrowprops=dict(arrowstyle="-|>", lw=2.0, color="blue", mutation_scale=12))
%     ax.text(x_start + 0.03*block_w, yR, f"FR: {FR:.2f} kN/m",
%             fontsize=8, ha="left", va="center", color="blue")
    
% label_horizontal_line(ax, Z, "GS [+2.5]", x=0.5, fs=8, offset_pts=6)
% label_horizontal_line(ax, 0.0, "DL [-1.5]",  x=-4, fs=8, offset_pts=6)

% ax.plot([0, 4], [Z - params["water_table_depth"], Z - params["water_table_depth"]], linestyle="--", linewidth=1.5, color="black")
% label_horizontal_line(ax, Z - params["water_table_depth"], "GWT [+1.03]", x=0.5, fs=8, offset_pts=6)

% ax.plot([-4, 0], [Z - params["water_level"], Z - params["water_level"]], linestyle="--", linewidth=1.5, color="black")
% label_horizontal_line(ax, Z - params["water_level"], "WL [+0.14]", x=-4, fs=8, offset_pts=6)

% ax.plot([p1[0], p2[0], p3[0], p4[0], p1[0]],
%     [p1[1], p2[1], p3[1], p4[1], p1[1]], color="black", linewidth=3)
% ax.plot([toe[0], left_end[0]], [toe[1], left_end[1]], linewidth=3, color="black")
% ax.plot([top[0], right_end[0]], [top[1], right_end[1]], linewidth=3, color="black")

% ax.set_xlim(x_wall - half_span, x_wall + half_span)
% ax.set_ylim(COMMON_Y_MIN, COMMON_Y_MAX + 1)
% ax.axis("off")

% plt.show()
% \end{lstlisting}

\section{Embedding depth $\sum M=0$}

\begin{lstlisting}[language=Python]
@dataclass
class SoilParams:
    unit_weight: Optional[float] = None
    cohesion: Optional[float] = None
    phi: Optional[float] = None
    delta: Optional[float] = None
    k_subgrade: Optional[float] = None
    modulus_E: Optional[float] = None
    permeability_k: Optional[float] = None
    unit_weight_sat: Optional[float] = None

@dataclass
class Layer:
    name: str
    top_depth: float
    bottom_depth: float
    params: SoilParams
    color: str = "#dddddd"

layers: List[Layer] = [
    Layer("Fill",             0.0,   2.0,  SoilParams(unit_weight=12.0, cohesion=20, phi=15.0, unit_weight_sat=12.0)),
    Layer("Fine–Medium Sand", 2.0,   7.0,  SoilParams(unit_weight=17.0, cohesion=0,  phi=30,   unit_weight_sat=19.0)),
    Layer("Clay",             7.0,  10.0,  SoilParams(unit_weight=14.0, cohesion=25, phi=17.5, unit_weight_sat=14.0)),
    Layer("Clayey Sand",     10.0,  15.0,  SoilParams(unit_weight=18.0, cohesion=0,  phi=25,   unit_weight_sat=20.0)),
    Layer("Clay",            15.0,  16.0,  SoilParams(unit_weight=14.0, cohesion=25, phi=17.5, unit_weight_sat=14.0)),
    Layer("Clayey Sand",     16.0,  17.5,  SoilParams(unit_weight=18.0, cohesion=0,  phi=25,   unit_weight_sat=20.0)),
    Layer("Medium Sand",     17.5,  32.5,  SoilParams(unit_weight=18.0, cohesion=0,  phi=32.5, unit_weight_sat=20.0)),
]

def label_horizontal_line(ax, y, text, x=0.0, fs=8, offset_pts=6):
    ax.annotate(text, xy=(x, y), xytext=(0, offset_pts),
                textcoords='offset points', ha='left', va='bottom', fontsize=fs, color='black')

def draw_layers_right_dashed(ax, top_point, block_width, layers,
                             fs=8, show_params=False, min_thk=0.5,
                             dash_pattern=(6, 4)):
    x0, y_top = top_point
    xL = x0; xR = xL + block_width
    boundaries = []
    for lyr in layers:
        boundaries += [y_top - lyr.top_depth, y_top - lyr.bottom_depth]
    boundaries = sorted(list({round(b, 6) for b in boundaries}))
    for y in boundaries:
        ax.plot([xL, xR], [y, y], linestyle=(0, dash_pattern), linewidth=1.2, color="black")
    if not show_params:
        return
    for lyr in layers:
        y1 = y_top - lyr.top_depth
        y2 = y_top - lyr.bottom_depth
        h  = y1 - y2
        if h < min_thk: 
            continue
        xc = (xL + xR) / 2.0
        sp = lyr.params
        lines = []
        if sp.unit_weight is not None:     lines.append(f"γ = {sp.unit_weight:g} kN/m³")
        if sp.unit_weight_sat is not None: lines.append(f"γ_sat = {sp.unit_weight_sat:g} kN/m³")
        if sp.cohesion    is not None:     lines.append(f"c = {sp.cohesion:g} kPa")
        if sp.phi         is not None:     lines.append(f"φ = {sp.phi:g}°")
        if lines:
            ax.annotate("\n".join(lines), xy=(xc, y1),
                        xytext=(0, -12), textcoords='offset points',
                        ha='center', va='top', fontsize=6, color='black')

def compute_active_pressures_with_interfaces(
    layers, water_table_depth, gamma_w=9.81, surcharge_q=0.0
):
    def Ka_of(phi_deg: float) -> float:
        if phi_deg is None: return 1.0
        a = np.deg2rad(45.0 - 0.5*phi_deg)
        return np.tan(a)**2

    nodes = {0.0, float(water_table_depth)}
    for L in layers:
        nodes.add(L.top_depth); nodes.add(L.bottom_depth)
    nodes = sorted(x for x in nodes if x >= 0.0)

    def layer_at(z_mid):
        for L in layers:
            if L.top_depth <= z_mid < L.bottom_depth: return L
        return layers[-1]

    def gamma_for_segment(L, z_top, z_bot):
        # effective γ below WT
        if z_bot <= water_table_depth:
            return (L.params.unit_weight or 0.0)
        else:
            if L.params.unit_weight_sat is not None:
                return (L.params.unit_weight_sat - 9.81)
            return (L.params.unit_weight or 0.0) - 9.81

    sigma_v_at_node = {0.0: surcharge_q}
    for k in range(1, len(nodes)):
        zt = nodes[k-1]; zb = nodes[k]; H = zb - zt
        Lseg  = layer_at((zt+zb)/2.0)
        gamma = gamma_for_segment(Lseg, zt, zb)
        sigma_v_at_node[zb] = sigma_v_at_node[zt] + gamma*H

    interfaces = []
    eps = 1e-9
    layer_bounds = sorted(
    ({L.bottom_depth for L in layers}
     | {L.top_depth for L in layers}
     | {water_table_depth})   # <- include GWT
)
    for zb in layer_bounds:
        if zb < 0.0: continue
        if zb not in sigma_v_at_node:
            keys = sorted(sigma_v_at_node.keys())
            j = np.searchsorted(keys, zb)
            z0, z1 = keys[j-1], keys[j]
            sv0, sv1 = sigma_v_at_node[z0], sigma_v_at_node[z1]
            sv = sv0 + (sv1 - sv0)*(zb - z0)/(z1 - z0)
        else:
            sv = sigma_v_at_node[zb]
        Labove = layer_at(max(zb - eps, 0.0)); Lbelow = layer_at(zb + eps)
        Ka_up  = Ka_of(Labove.params.phi or 0.0)
        Ka_dn  = Ka_of(Lbelow.params.phi or 0.0)
        interfaces.append(dict(
            z=zb, sigma_v=sv, Ka_up=Ka_up, Ka_dn=Ka_dn,
            p_up=Ka_up*sv, p_dn=Ka_dn*sv,
        ))

    df_i = pd.DataFrame(interfaces).sort_values("z").reset_index(drop=True)
    df_i = df_i.rename(columns={
        "z":"z [m]","sigma_v":"σ′v [kN/m²]","Ka_up":"Ka↑","Ka_dn":"Ka↓",
        "p_up":"p↑ = Ka↑·σ′v [kN/m²]","p_dn":"p↓ = Ka↓·σ′v [kN/m²]"
    })
    return df_i

def compute_passive_pressures_left_with_interfaces(
    layers, Z, t, water_table_depth, gamma_w=9.81, surcharge_q=0.0
):
    def Kp_of(phi_deg):
        a = np.deg2rad(45.0 + 0.5*(phi_deg or 0.0))
        return np.tan(a)**2

    z_top = float(Z); z_bot = float(Z + t); z_wt = float(water_table_depth)

    nodes = {z_top, z_bot}
    if z_top < z_wt < z_bot: nodes.add(z_wt)
    for L in layers:
        if z_top <= L.top_depth    <= z_bot: nodes.add(L.top_depth)
        if z_top <= L.bottom_depth <= z_bot: nodes.add(L.bottom_depth)
    nodes = sorted(nodes)

    def layer_at(z_mid):
        for L in layers:
            if L.top_depth <= z_mid < L.bottom_depth: return L
        return layers[-1]

    def gamma_eff(L, z1, z2):
        if z2 <= z_wt:
            return float(L.params.unit_weight or 0.0)
        else:
            if L.params.unit_weight_sat is not None:
                return float(L.params.unit_weight_sat) - 9.81
            return float(L.params.unit_weight or 0.0) - 9.81

    sigma_left = [0.0]
    for i in range(1, len(nodes)):
        z1, z2 = nodes[i-1], nodes[i]
        Lseg = layer_at((z1+z2)/2.0)
        sigma_left.append(sigma_left[-1] + gamma_eff(Lseg, z1, z2)*(z2 - z1))
    sigma_left = np.array(sigma_left)

    eps = 1e-9
    recs = []
    for zb in nodes:
        sv = float(np.interp(zb, np.array(nodes), sigma_left))
        Labove = layer_at(max(zb - eps, z_top))
        Lbelow = layer_at(min(zb + eps, z_bot - eps))
        Kp_up  = Kp_of(Labove.params.phi)
        Kp_dn  = Kp_of(Lbelow.params.phi)
        recs.append(dict(z=zb, sigma_v_left=sv, Kp_up=Kp_up, Kp_dn=Kp_dn,
                         p_up=Kp_up*sv, p_dn=Kp_dn*sv))

    df = pd.DataFrame(recs).sort_values("z").reset_index(drop=True)
    df = df.rename(columns={
        "z":"z [m]","sigma_v_left":"σ′v_left [kN/m²]","Kp_up":"Kp↑","Kp_dn":"Kp↓",
        "p_up":"p↑ = Kp↑·σ′v [kN/m²]","p_dn":"p↓ = Kp↓·σ′v [kN/m²]",
    })
    return df

Z       = float(params["Z"])                  # dredge depth (m)
alpha   = float(params["alpha_deg"])
betaL   = float(params["beta_left_deg"])
betaR   = float(params["beta_right_deg"])
wall_th = float(params["wall_thickness"])
fs      = int(params["font_size"])
block_w = float(params["dim_offset"])
z_wt    = float(params["water_table_depth"])  # RIGHT water surface depth (for total water)
z_wL    = float(params["water_level"])        # LEFT water surface depth (for total water)
gamma_w = 9.81

def build_rows_for_d(d: float):
    z_toe = Z + d

    # Active (right) up to toe (effective)
    df_i = compute_active_pressures_with_interfaces(layers, water_table_depth=z_wt)
    z_col  = "z [m]"; sv_col = "σ′v [kN/m²]"
    p_up_c = "p↑ = Ka↑·σ′v [kN/m²]"; p_dn_c = "p↓ = Ka↓·σ′v [kN/m²]"

    rows_df = df_i[df_i[z_col] <= z_toe].copy()
    if rows_df.empty or not np.isclose(rows_df[z_col].max(), z_toe):
        # interpolate Ka*σ′v at toe using Ka of layer just above toe
        sv_toe = float(np.interp(z_toe, df_i[z_col].to_numpy(), df_i[sv_col].to_numpy()))
        def _layer_at_right(z):
            for L in layers:
                if L.top_depth <= z < L.bottom_depth: return L
            return layers[-1]
        Ka_toe = np.tan(np.deg2rad(45.0 - 0.5*((_layer_at_right(z_toe-1e-6).params.phi) or 0.0)))**2
        p_toe = Ka_toe * sv_toe
        rows_df = pd.concat([rows_df, pd.DataFrame([{z_col:z_toe, p_up_c:p_toe, p_dn_c:p_toe}])],
                            ignore_index=True)
    rows_active = rows_df.sort_values(z_col).to_dict("records")

    # Passive (left) Z→Z+d (effective)
    df_pass = compute_passive_pressures_left_with_interfaces(layers, Z=Z, t=d, water_table_depth=z_wt)
    p_up_p = "p↑ = Kp↑·σ′v [kN/m²]"; p_dn_p = "p↓ = Kp↓·σ′v [kN/m²]"
    rows_p = df_pass[df_pass["z [m]"] <= z_toe].sort_values("z [m]").to_dict("records")

    return rows_active, rows_p, (z_col, p_dn_c, p_up_c), ("z [m]", p_dn_p, p_up_p), z_toe

def build_hydro_rows_side(z_top: float, z_bot: float, gamma_w: float = 9.81):
    """Return [top,bottom] rows for hydro between z_top and z_bot (if z_top < z_bot)."""
    z_top, z_bot = float(z_top), float(z_bot)
    if z_top >= z_bot:
        return [], ("z [m]","u_dn [kN/m²]","u_up [kN/m²]")
    def u(z): return gamma_w * (z - z_top)
    rows = [{"z [m]": z, "u_dn [kN/m²]": u(z), "u_up [kN/m²]": u(z)} for z in [z_top, z_bot]]
    return rows, ("z [m]","u_dn [kN/m²]","u_up [kN/m²]")

def hydro_triangle_resultant(z_top: float, z_bot: float, gamma_w: float = 9.81):
    """Resultant and centroid for triangular hydro u(z)=γw(z-z_top) over [z_top,z_bot]."""
    H = float(z_bot) - float(z_top)
    F = 0.5 * gamma_w * H * H
    zc = float(z_top) + (2.0/3.0) * H   # 1/3 above bottom
    return F, zc

def decompose_components(rows, z_key, p_top_key, p_bot_key, z_start, z_end):
    segs = sorted([r for r in rows if z_start <= float(r[z_key]) <= z_end],
                  key=lambda r: float(r[z_key]))
    comps = []
    for i in range(len(segs)-1):
        zt = float(segs[i][z_key]); zb = float(segs[i+1][z_key]); H = zb - zt
        if H <= 0: 
            continue
        pt = float(segs[i][p_top_key])
        pb = float(segs[i+1][p_bot_key])
        pmin = min(pt, pb); dp = pb - pt
        F_rect = pmin * H
        if F_rect > 1e-12:
            comps.append(dict(kind="rect", seg=i+1, F=F_rect, zc=zt + 0.5*H))
        F_tri = 0.5 * abs(dp) * H
        if F_tri > 1e-12:
            zc_tri = zt + (2.0/3.0*H if dp > 0 else 1.0/3.0*H)
            comps.append(dict(kind="tri", seg=i+1, F=F_tri, zc=zc_tri))
    return comps

def M_total_about_base(d: float) -> Tuple[float, list, list, list, list, float]:
    """Return ΣM_base (CCW +), components (active, passive, hydro_left, hydro_right), and z_toe."""
    rows_active, rows_p, keysA, keysP, z_toe = build_rows_for_d(d)
    zA, pA_dn, pA_up = keysA
    zP, pP_dn, pP_up = keysP

    # Soil components (effective)
    active_comps  = decompose_components(rows_active, zA, pA_dn, pA_up, 0.0, z_toe)  # right → CCW(+)
    passive_comps = decompose_components(rows_p,      zP, pP_dn, pP_up, Z,  z_toe)   # left  → CW(-)

    # Hydro (TOTAL water) to TOE on both faces
    hydroL_comps, hydroR_comps = [], []
    if z_wL < z_toe:
        FL, zcL = hydro_triangle_resultant(z_wL, z_toe, gamma_w)
        hydroL_comps = [dict(kind="tri", seg=1, F=FL, zc=zcL)]          # left → CW(-)
    if z_wt < z_toe:
        FR, zcR = hydro_triangle_resultant(z_wt, z_toe, gamma_w)
        hydroR_comps = [dict(kind="tri", seg=1, F=FR, zc=zcR)]          # right → CCW(+)

    z_base = z_toe
    M_act = sum(+c["F"] * (z_base - c["zc"]) for c in active_comps)     # CCW(+)
    M_pas = sum(-c["F"] * (z_base - c["zc"]) for c in passive_comps)    # CW(-)
    M_hL  = sum(-c["F"] * (z_base - c["zc"]) for c in hydroL_comps)     # CW(-)
    M_hR  = sum(+c["F"] * (z_base - c["zc"]) for c in hydroR_comps)     # CCW(+)

    return (M_act + M_pas + M_hL + M_hR), active_comps, passive_comps, hydroL_comps, hydroR_comps, z_toe

def solve_d_by_moment(d_lo: float, d_hi: float, tol: float = 1e-4):
    grid = np.linspace(d_lo, d_hi, 120)
    Mvals = np.array([M_total_about_base(dv)[0] for dv in grid])
    idx = np.where(np.sign(Mvals[:-1]) * np.sign(Mvals[1:]) <= 0)[0]

    if idx.size > 0:
        a = float(grid[idx[0]]); b = float(grid[idx[0]+1])
        Ma = M_total_about_base(a)[0]; Mb = M_total_about_base(b)[0]
        for _ in range(100):
            c = 0.5*(a+b)
            Mc = M_total_about_base(c)[0]
            if abs(Mc) < tol or abs(b-a) < tol*(1+abs(c)):
                return c, True
            if np.sign(Ma) * np.sign(Mc) <= 0:
                b, Mb = c, Mc
            else:
                a, Ma = c, Mc
        return 0.5*(a+b), True

    # fallback: minimize |M|
    def obj(d): return abs(M_total_about_base(d)[0])
    gr = (np.sqrt(5)-1)/2
    a, b = d_lo, d_hi
    c = b - gr*(b-a); d = a + gr*(b-a)
    fc, fd = obj(c), obj(d)
    for _ in range(120):
        if abs(b-a) < tol*(1+abs(c)+abs(d)): break
        if fc > fd:
            a, c, fc = c, d, fd
            d = a + gr*(b-a); fd = obj(d)
        else:
            b, d, fd = d, c, fc
            c = b - gr*(b-a); fc = obj(c)
    return 0.5*(a+b), False

d_min = max(0.01, 0.01*Z)
d_max = min(0.95*(layers[-1].bottom_depth - Z), max(6.0, 5.0*Z))

d_star, has_root = solve_d_by_moment(d_min, d_max)
M_res, active_comps, passive_comps, hydroL_comps, hydroR_comps, z_toe = M_total_about_base(d_star)
status = "equilibrium" if abs(M_res) < 1e-4 and has_root else "min |ΣM|"
print(f"Moment {status}: t = {d_star:.3f} m")
print(f"ΣM_O = {M_res:+.4f} kN·m/m")

fig, ax = plt.subplots(figsize=params["figsize"])

label_horizontal_line(ax, Z, "GS [+2.5]", x=0.25, fs=8, offset_pts=6)
label_horizontal_line(ax, 0.0, "DL [-1.5]",  x=-4, fs=8, offset_pts=6)

ax.plot([0, 4], [Z - params["water_table_depth"], Z - params["water_table_depth"]], linestyle="--", linewidth=1.5, color="black")
label_horizontal_line(ax, Z - params["water_table_depth"], "GWT [+1.03]", x=0.25, fs=8, offset_pts=6)

ax.plot([-4, 0], [Z - params["water_level"], Z - params["water_level"]], linestyle="--", linewidth=1.5, color="black")
label_horizontal_line(ax, Z - params["water_level"], "WL [+0.14]", x=-4, fs=8, offset_pts=6)

theta_wall = 90.0 - alpha
uvec = np.array([np.cos(np.deg2rad(theta_wall)), np.sin(np.deg2rad(theta_wall))])

toe  = np.array([0.0, 0.0])           # dredge datum
top  = toe + uvec * Z                 # ground surface point on wall
base = toe - uvec * d_star            # embedded tip at z = Z + d_star

nvec = np.array([-uvec[1], uvec[0]])
p1 = top  + nvec*(wall_th/2); p2 = base + nvec*(wall_th/2)
p3 = base - nvec*(wall_th/2); p4 = top  - nvec*(wall_th/2)
ax.plot([p1[0], p2[0], p3[0], p4[0], p1[0]],
        [p1[1], p2[1], p3[1], p4[1], p1[1]], color="black", linewidth=3)

left_end  = np.array([-block_w, -np.tan(np.deg2rad(betaL))*block_w])
right_end = top + np.array([block_w, np.tan(np.deg2rad(betaR))*block_w])
ax.plot([toe[0], left_end[0] ], [toe[1], left_end[1] ], linewidth=3, color="black")
ax.plot([top[0], right_end[0]], [top[1], right_end[1]], linewidth=3, color="black")
draw_layers_right_dashed(ax, top_point=top, block_width=block_w, layers=layers, show_params=False)

x_face_left  = min(p1[0], p2[0], p3[0], p4[0])
x_face_right = max(p1[0], p2[0], p3[0], p4[0])

rows_active, rows_p, (zA,pA_dn,pA_up), (zP,pP_dn,pP_up), z_toe = build_rows_for_d(d_star)

rows_hL, (zHL,uL_dn,uL_up) = build_hydro_rows_side(z_wL, z_toe, gamma_w)
rows_hR, (zHR,uR_dn,uR_up) = build_hydro_rows_side(z_wt, z_toe, gamma_w)

def pmax_of_rows(rows, p_dn, p_up):
    if not rows: return 0.0
    vals = [float(rows[0][p_dn])] + [float(r[p_up]) for r in rows]
    return max(vals)

pmax_active  = pmax_of_rows(rows_active, pA_dn, pA_up)
pmax_passive = pmax_of_rows(rows_p,      pP_dn, pP_up)
pmax_hL      = pmax_of_rows(rows_hL,     uL_dn, uL_up) if rows_hL else 0.0
pmax_hR      = pmax_of_rows(rows_hR,     uR_dn, uR_up) if rows_hR else 0.0
target = 0.40 * block_w
scale_both = target / max(pmax_active, pmax_passive, pmax_hL, pmax_hR, 1e-12)

def draw_wedge_right(rows, z_key, p_dn, p_up, x_wall, color):
    if not rows: return
    xs, ys = [], []
    xs.append(x_wall + float(rows[0][p_dn]) * scale_both)
    ys.append(Z - float(rows[0][z_key]))
    for i in range(len(rows)-1):
        zb = float(rows[i+1][z_key])
        p_end = float(rows[i+1][p_up])
        x1 = x_wall + p_end*scale_both; y1 = Z - zb
        xs += [x1]; ys += [y1]
        p_next = float(rows[i+1][p_dn])
        x_next = x_wall + p_next*scale_both
        if abs(x1 - x_next) > 1e-12:
            xs += [x_next]; ys += [y1]
    xs, ys = np.array(xs), np.array(ys)
    ax.plot(xs, ys, color=color, lw=2)
    ax.fill_betweenx(ys, x_wall, xs, color=color, alpha=0.30)

def draw_wedge_left(rows, z_key, p_dn, p_up, x_wall, color):
    if not rows: return
    xs, ys = [], []
    xs.append(x_wall - float(rows[0][p_dn]) * scale_both)
    ys.append(Z - float(rows[0][z_key]))
    for i in range(len(rows)-1):
        zb = float(rows[i+1][z_key])
        p_end = float(rows[i+1][p_up])
        x1 = x_wall - p_end*scale_both; y1 = Z - zb
        xs += [x1]; ys += [y1]
        p_next = float(rows[i+1][p_dn])
        x_next = x_wall - p_next*scale_both
        if abs(x1 - x_next) > 1e-12:
            xs += [x_next]; ys += [y1]
    xs, ys = np.array(xs), np.array(ys)
    ax.plot(xs, ys, color=color, lw=2)
    ax.fill_betweenx(ys, xs, x_wall, color=color, alpha=0.30)

def draw_components(comps, x_wall, to_wall_sign, color, prefix):
    if not comps: return
    Fref = max([c["F"] for c in comps] + [1e-12])
    s = (1.0 * block_w) / Fref
    comps = sorted(comps, key=lambda c: c["zc"])
    for k, c in enumerate(comps, start=1):
        L  = c["F"] * s
        y  = Z - c["zc"]
        ax.plot([x_wall-0.06, x_wall+0.06], [y, y], color=color, lw=1.4)
        if to_wall_sign > 0:   # left face → arrow points +x (into wall)
            xy, xytext = (x_wall, y), (x_wall - L, y)
            ha, xlab = "right", x_wall - L - 0.03*block_w
        else:                   # right face → arrow points -x (into wall)
            xy, xytext = (x_wall, y), (x_wall + L, y)
            ha, xlab = "left",  x_wall + L + 0.03*block_w
        ax.annotate("", xy=xy, xytext=xytext,
                    arrowprops=dict(arrowstyle="-|>", lw=2.0, color=color, mutation_scale=8.0))
        ax.text(xlab, y + (0.06 if k%2 else -0.06),
                f"{prefix}{k} ({c['kind']}): {c['F']:.2f} kN/m",
                fontsize=8, ha=ha, va="center", color=color)

draw_components(active_comps,   x_face_right, -1, "red",       "Fₐ")
draw_components(passive_comps,  x_face_left,  +1, "navy",      "Fₚ")
draw_components(hydroL_comps,   x_face_left,  +1, "blue",      "F_wL")
draw_components(hydroR_comps,   x_face_right, -1, "blue",      "F_wR")

z_base = z_toe
def moments_table(comps, side_label, sign_ccw):
    rows = []
    for c in sorted(comps, key=lambda r: (r["seg"], r["kind"])):
        arm = z_base - c["zc"]
        M   = sign_ccw * c["F"] * arm
        rows.append(dict(Side=side_label, Segment=c["seg"], Shape=c["kind"],
                         **{"F [kN/m]":c["F"], "z_c [m]":c["zc"], "Arm to base [m]":arm, "M_base [kN·m/m]":M}))
    return pd.DataFrame(rows)

dfMa = moments_table(active_comps,   "Active (right)", +1)
dfMp = moments_table(passive_comps,  "Passive (left)", -1)
dfMwL= moments_table(hydroL_comps,   "Hydro (left)",   -1)
dfMwR= moments_table(hydroR_comps,   "Hydro (right)",  +1)
dfM  = pd.concat([dfMa, dfMp, dfMwL, dfMwR], ignore_index=True).sort_values(["Side","Segment","Shape"])
display(dfM.style.format({"F [kN/m]":"{:.2f}", "z_c [m]":"{:.2f}",
                          "Arm to base [m]":"{:.2f}", "M_base [kN·m/m]":"{:+.2f}"}))

z_O = z_toe; y_O = Z - z_O
x_wall = 0.5 * (x_face_left + x_face_right)
ax.plot([x_wall], [y_O], marker="o", markersize=7, color="red", markeredgewidth=0.8, zorder=21, clip_on=False)
ax.annotate("O", xy=(x_wall, y_O), xytext=(6, -10),
            textcoords="offset points", color="red", fontsize=9, ha="left", va="top")

COMMON_X_MIN = -12
COMMON_X_MAX = params["dim_offset"] + params["layer_block_width"]
COMMON_Y_MIN = -d_star
COMMON_Y_MAX = params["Z"]

LINE_BREAK = chr(10)

def apply_common_axes(ax):
    ax.set_aspect("equal", adjustable="box")
    ax.set_xlim(COMMON_X_MIN, COMMON_X_MAX)
    ax.set_ylim(COMMON_Y_MIN, COMMON_Y_MAX)

half_span = max(abs(COMMON_X_MIN - x_wall), abs(COMMON_X_MAX - x_wall))
ax.set_xlim(x_wall - half_span, x_wall + half_span)
ax.set_ylim(COMMON_Y_MIN, COMMON_Y_MAX + 1)

dw = desired_width if 'desired_width' in globals() else 0.6
dh = desired_height if 'desired_height' in globals() else 0.8
left = (1.0 - dw) / 2.0
bottom = (1.0 - dh) / 2.0
ax.set_position([left, bottom, dw, dh])

ax.axis("off")
plt.show()
\end{lstlisting}


\section{Moment line $t = 10.172$ meters}

\begin{lstlisting}[language=Python]
# DA1-2

A1 = {
    "gamma_G_unfavourable": 1.00,  # earth pressures (active/passive)
    "gamma_Q_unfavourable": 1.00,  # hydrostatic
}
gamma_G_unfav = A1["gamma_G_unfavourable"]
gamma_Q_unfav = A1["gamma_Q_unfavourable"]

@dataclass
class SoilParams:
    unit_weight: Optional[float] = None
    cohesion: Optional[float] = None
    phi: Optional[float] = None
    delta: Optional[float] = None
    k_subgrade: Optional[float] = None
    modulus_E: Optional[float] = None
    permeability_k: Optional[float] = None
    unit_weight_sat: Optional[float] = None

@dataclass
class Layer:
    name: str
    top_depth: float
    bottom_depth: float
    params: SoilParams
    color: str = "#dddddd"

layers: List[Layer] = [
    Layer("Fill",             0.0,   2.0,  SoilParams(unit_weight=12.0, cohesion=20/1.40, phi=12.1, unit_weight_sat=12.0)),
    Layer("Fine–Medium Sand", 2.0,   7.0,  SoilParams(unit_weight=17.0, cohesion=0,  phi=24.8,   unit_weight_sat=19.0)),
    Layer("Clay",             7.0,  10.0,  SoilParams(unit_weight=14.0, cohesion=25/1.40, phi=14.2, unit_weight_sat=14.0)),
    Layer("Clayey Sand",     10.0,  15.0,  SoilParams(unit_weight=18.0, cohesion=0,  phi=20.5,   unit_weight_sat=20.0)),
    Layer("Clay",            15.0,  16.0,  SoilParams(unit_weight=14.0, cohesion=25/1.40, phi=14.2, unit_weight_sat=14.0)),
    Layer("Clayey Sand",     16.0,  17.5,  SoilParams(unit_weight=18.0, cohesion=0,  phi=20.5,   unit_weight_sat=20.0)),
    Layer("Medium Sand",     17.5,  32.5,  SoilParams(unit_weight=18.0, cohesion=0,  phi=27.0, unit_weight_sat=20.0)),
]

def label_horizontal_line(ax, y, text, x=0.0, fs=8, offset_pts=6):
    ax.annotate(text, xy=(x, y), xytext=(0, offset_pts),
                textcoords='offset points', ha='left', va='bottom', fontsize=fs, color='black')

def draw_layers_right_dashed(ax, top_point, block_width, layers,
                             fs=8, show_params=False, min_thk=0.5,
                             dash_pattern=(6, 4)):
    x0, y_top = top_point
    xL = x0; xR = xL + block_width
    boundaries = []
    for lyr in layers:
        boundaries += [y_top - lyr.top_depth, y_top - lyr.bottom_depth]
    boundaries = sorted(list({round(b, 6) for b in boundaries}))
    for y in boundaries:
        ax.plot([xL, xR], [y, y], linestyle=(0, dash_pattern), linewidth=1.2, color="black")
    if not show_params:
        return
    for lyr in layers:
        y1 = y_top - lyr.top_depth
        y2 = y_top - lyr.bottom_depth
        h  = y1 - y2
        if h < min_thk: 
            continue
        xc = (xL + xR) / 2.0
        sp = lyr.params
        lines = []
        if sp.unit_weight is not None:     lines.append(f"γ = {sp.unit_weight:g} kN/m³")
        if sp.unit_weight_sat is not None: lines.append(f"γ_sat = {sp.unit_weight_sat:g} kN/m³")
        if sp.cohesion    is not None:     lines.append(f"c = {sp.cohesion:g} kPa")
        if sp.phi         is not None:     lines.append(f"φ = {sp.phi:g}°")
        if lines:
            ax.annotate("\n".join(lines), xy=(xc, y1),
                        xytext=(0, -12), textcoords='offset points',
                        ha='center', va='top', fontsize=6, color='black')

def compute_active_pressures_with_interfaces(
    layers, water_table_depth, gamma_w=9.81, surcharge_q=0.0
):
    def Ka_of(phi_deg: float) -> float:
        if phi_deg is None: return 1.0
        a = np.deg2rad(45.0 - 0.5*phi_deg)
        return np.tan(a)**2

    nodes = {0.0, float(water_table_depth)}
    for L in layers:
        nodes.add(L.top_depth); nodes.add(L.bottom_depth)
    nodes = sorted(x for x in nodes if x >= 0.0)

    def layer_at(z_mid):
        for L in layers:
            if L.top_depth <= z_mid < L.bottom_depth: return L
        return layers[-1]

    def gamma_for_segment(L, z_top, z_bot):
        # effective γ below WT
        if z_bot <= water_table_depth:
            return (L.params.unit_weight or 0.0)
        else:
            if L.params.unit_weight_sat is not None:
                return (L.params.unit_weight_sat - 9.81)
            return (L.params.unit_weight or 0.0) - 9.81

    sigma_v_at_node = {0.0: surcharge_q}
    for k in range(1, len(nodes)):
        zt = nodes[k-1]; zb = nodes[k]; H = zb - zt
        Lseg  = layer_at((zt+zb)/2.0)
        gamma = gamma_for_segment(Lseg, zt, zb)
        sigma_v_at_node[zb] = sigma_v_at_node[zt] + gamma*H

    interfaces = []
    eps = 1e-9
    layer_bounds = sorted({L.bottom_depth for L in layers} | {L.top_depth for L in layers} | {0.0, float(water_table_depth)})
    for zb in layer_bounds:
        if zb < 0.0: continue
        if zb not in sigma_v_at_node:
            keys = sorted(sigma_v_at_node.keys())
            j = np.searchsorted(keys, zb)
            z0, z1 = keys[j-1], keys[j]
            sv0, sv1 = sigma_v_at_node[z0], sigma_v_at_node[z1]
            sv = sv0 + (sv1 - sv0)*(zb - z0)/(z1 - z0)
        else:
            sv = sigma_v_at_node[zb]
        Labove = layer_at(max(zb - eps, 0.0)); Lbelow = layer_at(zb + eps)
        Ka_up  = Ka_of(Labove.params.phi or 0.0)
        Ka_dn  = Ka_of(Lbelow.params.phi or 0.0)
        interfaces.append(dict(
            z=zb, sigma_v=sv, Ka_up=Ka_up, Ka_dn=Ka_dn,
            p_up=Ka_up*sv, p_dn=Ka_dn*sv,
        ))

    df_i = pd.DataFrame(interfaces).sort_values("z").reset_index(drop=True)
    df_i = df_i.rename(columns={
        "z":"z [m]","sigma_v":"σ′v [kN/m²]","Ka_up":"Ka↑","Ka_dn":"Ka↓",
        "p_up":"p↑ = Ka↑·σ′v [kN/m²]","p_dn":"p↓ = Ka↓·σ′v [kN/m²]"
    })
    return df_i

def compute_passive_pressures_left_with_interfaces(
    layers, Z, t, water_table_depth, gamma_w=9.81, surcharge_q=0.0
):
    def Kp_of(phi_deg):
        a = np.deg2rad(45.0 + 0.5*(phi_deg or 0.0))
        return np.tan(a)**2

    z_top = float(Z); z_bot = float(Z + t); z_wt = float(water_table_depth)

    nodes = {z_top, z_bot}
    if z_top < z_wt < z_bot: nodes.add(z_wt)
    for L in layers:
        if z_top <= L.top_depth    <= z_bot: nodes.add(L.top_depth)
        if z_top <= L.bottom_depth <= z_bot: nodes.add(L.bottom_depth)
    nodes = sorted(nodes)

    def layer_at(z_mid):
        for L in layers:
            if L.top_depth <= z_mid < L.bottom_depth: return L
        return layers[-1]

    def gamma_eff(L, z1, z2):
        if z2 <= z_wt:
            return float(L.params.unit_weight or 0.0)
        else:
            if L.params.unit_weight_sat is not None:
                return float(L.params.unit_weight_sat) - 9.81
            return float(L.params.unit_weight or 0.0) - 9.81

    sigma_left = [0.0]
    for i in range(1, len(nodes)):
        z1, z2 = nodes[i-1], nodes[i]
        Lseg = layer_at((z1+z2)/2.0)
        sigma_left.append(sigma_left[-1] + gamma_eff(Lseg, z1, z2)*(z2 - z1))
    sigma_left = np.array(sigma_left)

    eps = 1e-9
    recs = []
    for zb in nodes:
        sv = float(np.interp(zb, np.array(nodes), sigma_left))
        Labove = layer_at(max(zb - eps, z_top))
        Lbelow = layer_at(min(zb + eps, z_bot - eps))
        Kp_up  = Kp_of(Labove.params.phi)
        Kp_dn  = Kp_of(Lbelow.params.phi)
        recs.append(dict(z=zb, sigma_v_left=sv, Kp_up=Kp_up, Kp_dn=Kp_dn,
                         p_up=Kp_up*sv, p_dn=Kp_dn*sv))

    df = pd.DataFrame(recs).sort_values("z").reset_index(drop=True)
    df = df.rename(columns={
        "z":"z [m]","sigma_v_left":"σ′v_left [kN/m²]","Kp_up":"Kp↑","Kp_dn":"Kp↓",
        "p_up":"p↑ = Kp↑·σ′v [kN/m²]","p_dn":"p↓ = Kp↓·σ′v [kN/m²]",
    })
    return df

Z       = float(params["Z"])                  # dredge depth (m)
alpha   = float(params["alpha_deg"])
betaL   = float(params["beta_left_deg"])
betaR   = float(params["beta_right_deg"])
wall_th = float(params["wall_thickness"])
fs      = int(params["font_size"])
block_w = float(params["dim_offset"])
z_wt    = float(params["water_table_depth"])  # RIGHT water surface depth (for total water)
z_wL    = float(params["water_level"])        # LEFT water surface depth (for total water)
gamma_w = 9.81

def build_rows_for_d(d: float):
    z_toe = Z + d

    # Active (right) up to toe (effective)
    df_i = compute_active_pressures_with_interfaces(layers, water_table_depth=z_wt)
    z_col  = "z [m]"; sv_col = "σ′v [kN/m²]"
    p_up_c = "p↑ = Ka↑·σ′v [kN/m²]"; p_dn_c = "p↓ = Ka↓·σ′v [kN/m²]"

    rows_df = df_i[df_i[z_col] <= z_toe].copy()
    if rows_df.empty or not np.isclose(rows_df[z_col].max(), z_toe):
        # interpolate Ka*σ′v at toe using Ka of layer just above toe
        sv_toe = float(np.interp(z_toe, df_i[z_col].to_numpy(), df_i[sv_col].to_numpy()))
        def _layer_at_right(z):
            for L in layers:
                if L.top_depth <= z < L.bottom_depth: return L
            return layers[-1]
        Ka_toe = np.tan(np.deg2rad(45.0 - 0.5*((_layer_at_right(z_toe-1e-6).params.phi) or 0.0)))**2
        p_toe = Ka_toe * sv_toe
        rows_df = pd.concat([rows_df, pd.DataFrame([{z_col:z_toe, p_up_c:p_toe, p_dn_c:p_toe}])],
                            ignore_index=True)
    rows_active = rows_df.sort_values(z_col).to_dict("records")

    # Passive (left) Z→Z+d (effective)
    df_pass = compute_passive_pressures_left_with_interfaces(layers, Z=Z, t=d, water_table_depth=z_wt)
    p_up_p = "p↑ = Kp↑·σ′v [kN/m²]"; p_dn_p = "p↓ = Kp↓·σ′v [kN/m²]"
    rows_p = df_pass[df_pass["z [m]"] <= z_toe].sort_values("z [m]").to_dict("records")

    return rows_active, rows_p, (z_col, p_dn_c, p_up_c), ("z [m]", p_dn_p, p_up_p), z_toe

def build_hydro_rows_side(z_top: float, z_bot: float, gamma_w: float = 9.81):
    """Return [top,bottom] rows for hydro between z_top and z_bot (if z_top < z_bot)."""
    z_top, z_bot = float(z_top), float(z_bot)
    if z_top >= z_bot:
        return [], ("z [m]","u_dn [kN/m²]","u_up [kN/m²]")
    def u(z): return gamma_w * (z - z_top)
    rows = [{"z [m]": z, "u_dn [kN/m²]": u(z), "u_up [kN/m²]": u(z)} for z in [z_top, z_bot]]
    return rows, ("z [m]","u_dn [kN/m²]","u_up [kN/m²]")

def hydro_triangle_resultant(z_top: float, z_bot: float, gamma_w: float = 9.81, factor: float = 1.0):
    """Resultant and centroid for triangular hydro u(z)=γw(z-z_top) over [z_top,z_bot], with factor."""
    H = float(z_bot) - float(z_top)
    F = 0.5 * gamma_w * H * H * factor
    zc = float(z_top) + (2.0/3.0) * H   # 1/3 above bottom
    return F, zc

def decompose_components(rows, z_key, p_top_key, p_bot_key, z_start, z_end, factor: float = 1.0):
    segs = sorted([r for r in rows if z_start <= float(r[z_key]) <= z_end],
                  key=lambda r: float(r[z_key]))
    comps = []
    for i in range(len(segs)-1):
        zt = float(segs[i][z_key]); zb = float(segs[i+1][z_key]); H = zb - zt
        if H <= 0:
            continue
        pt = float(segs[i][p_top_key])
        pb = float(segs[i+1][p_bot_key])
        pmin = min(pt, pb); dp = pb - pt

        F_rect = pmin * H * factor
        if F_rect > 1e-12:
            comps.append(dict(kind="rect", seg=i+1, F=F_rect, zc=zt + 0.5*H))

        F_tri = 0.5 * abs(dp) * H * factor
        if F_tri > 1e-12:
            zc_tri = zt + (2.0/3.0*H if dp > 0 else 1.0/3.0*H)
            comps.append(dict(kind="tri", seg=i+1, F=F_tri, zc=zc_tri))
    return comps

def M_total_about_base(d: float) -> Tuple[float, list, list, list, list, float]:
    """Return ΣM_base (CCW +), components (active, passive, hydro_left, hydro_right), and z_toe."""
    rows_active, rows_p, keysA, keysP, z_toe = build_rows_for_d(d)
    zA, pA_dn, pA_up = keysA
    zP, pP_dn, pP_up = keysP

    # Soil components (effective) with γ_G,unfav
    active_comps  = decompose_components(rows_active, zA, pA_dn, pA_up, 0.0, z_toe, factor=gamma_G_unfav)  # right → CCW(+)
    passive_comps = decompose_components(rows_p,      zP, pP_dn, pP_up, Z,  z_toe, factor=gamma_G_unfav)  # left  → CW(-)

    # Hydro (TOTAL water) to TOE on both faces with γ_Q,unfav
    hydroL_comps, hydroR_comps = [], []
    if z_wL < z_toe:
        FL, zcL = hydro_triangle_resultant(z_wL, z_toe, gamma_w, factor=gamma_G_unfav)
        hydroL_comps = [dict(kind="tri", seg=1, F=FL, zc=zcL)]          # left → CW(-)
    if z_wt < z_toe:
        FR, zcR = hydro_triangle_resultant(z_wt, z_toe, gamma_w, factor=gamma_G_unfav)
        hydroR_comps = [dict(kind="tri", seg=1, F=FR, zc=zcR)]          # right → CCW(+)

    z_base = z_toe
    M_act = sum(+c["F"] * (z_base - c["zc"]) for c in active_comps)     # CCW(+)
    M_pas = sum(-c["F"] * (z_base - c["zc"]) for c in passive_comps)    # CW(-)
    M_hL  = sum(-c["F"] * (z_base - c["zc"]) for c in hydroL_comps)     # CW(-)
    M_hR  = sum(+c["F"] * (z_base - c["zc"]) for c in hydroR_comps)     # CCW(+)

    return (M_act + M_pas + M_hL + M_hR), active_comps, passive_comps, hydroL_comps, hydroR_comps, z_toe

def solve_d_by_moment(d_lo: float, d_hi: float, tol: float = 1e-4):
    grid = np.linspace(d_lo, d_hi, 120)
    Mvals = np.array([M_total_about_base(dv)[0] for dv in grid])
    idx = np.where(np.sign(Mvals[:-1]) * np.sign(Mvals[1:]) <= 0)[0]

    if idx.size > 0:
        a = float(grid[idx[0]]); b = float(grid[idx[0]+1])
        Ma = M_total_about_base(a)[0]; Mb = M_total_about_base(b)[0]
        for _ in range(100):
            c = 0.5*(a+b)
            Mc = M_total_about_base(c)[0]
            if abs(Mc) < tol or abs(b-a) < tol*(1+abs(c)):
                return c, True
            if np.sign(Ma) * np.sign(Mc) <= 0:
                b, Mb = c, Mc
            else:
                a, Ma = c, Mc
        return 0.5*(a+b), True

    # fallback: minimize |M|
    def obj(d): return abs(M_total_about_base(d)[0])
    gr = (np.sqrt(5)-1)/2
    a, b = d_lo, d_hi
    c = b - gr*(b-a); d = a + gr*(b-a)
    fc, fd = obj(c), obj(d)
    for _ in range(120):
        if abs(b-a) < tol*(1+abs(c)+abs(d)): break
        if fc > fd:
            a, c, fc = c, d, fd
            d = a + gr*(b-a); fd = obj(d)
        else:
            b, d, fd = d, c, fc
            c = b - gr*(b-a); fc = obj(c)
    return 0.5*(a+b), False

d_min = max(0.1, 0.02*Z)
d_max = min(0.95*(layers[-1].bottom_depth - Z), max(6.0, 5.0*Z))

d_star, has_root = solve_d_by_moment(d_min, d_max)
M_res, active_comps, passive_comps, hydroL_comps, hydroR_comps, z_toe = M_total_about_base(d_star)
status = "equilibrium" if abs(M_res) < 1e-4 and has_root else "min |ΣM|"
print(f"Moment {status}: t = {d_star:.3f} m")
print(f"ΣM_O = {M_res:+.4f} kN·m/m")

fig, ax = plt.subplots(figsize=params["figsize"])

theta_wall = 90.0 - alpha
wall_th = 0.0
uvec = np.array([np.cos(np.deg2rad(theta_wall)), np.sin(np.deg2rad(theta_wall))])
toe  = np.array([0.0, 0.0])
top  = toe + uvec * Z
base = toe - uvec * d_star
nvec = np.array([-uvec[1], uvec[0]])
p1 = top  + nvec*(wall_th/2); p2 = base + nvec*(wall_th/2)
p3 = base - nvec*(wall_th/2); p4 = top  - nvec*(wall_th/2)
ax.plot([p1[0], p2[0], p3[0], p4[0], p1[0]],
        [p1[1], p2[1], p3[1], p4[1], p1[1]], color="black", linewidth=3)

x_face_left  = min(p1[0], p2[0], p3[0], p4[0])
x_face_right = max(p1[0], p2[0], p3[0], p4[0])

z_base = z_toe
def moments_table(comps, side_label, sign_ccw):
    rows = []
    for c in sorted(comps, key=lambda r: (r["seg"], r["kind"])):
        arm = z_base - c["zc"]
        M   = sign_ccw * c["F"] * arm
        rows.append(dict(Side=side_label, Segment=c["seg"], Shape=c["kind"],
                         **{"F [kN/m]":c["F"], "z_c [m]":c["zc"], "Arm to base [m]":arm, "M_base [kN·m/m]":M}))
    return pd.DataFrame(rows)

dfMa = moments_table(active_comps,   "Active (right)", +1)
dfMp = moments_table(passive_comps,  "Passive (left)", -1)
dfMwL= moments_table(hydroL_comps,   "Hydro (left)",   -1)
dfMwR= moments_table(hydroR_comps,   "Hydro (right)",  +1)
dfM  = pd.concat([dfMa, dfMp, dfMwL, dfMwR], ignore_index=True).sort_values(["Side","Segment","Shape"])

def _build_segments(rows, z_key, p_top_key, p_bot_key, factor: float = 1.0):
    """
    Build linear segments p(z) = A + B z between consecutive nodes, applying factor to pressures.
    """
    segs = []
    if not rows:
        return segs
    for i in range(len(rows) - 1):
        zt = float(rows[i][z_key])
        zb = float(rows[i+1][z_key])
        if zb <= zt:
            continue
        pt_raw = float(rows[i][p_top_key])
        pb_raw = float(rows[i+1][p_bot_key])
        pt = factor * pt_raw
        pb = factor * pb_raw
        m  = (pb - pt) / (zb - zt)
        A  = pt - m*zt
        B  = m
        segs.append(dict(zt=zt, zb=zb, pt=pt, pb=pb, A=A, B=B))
    return segs

def _clip(a, b, lo, hi):
    aa = max(a, lo); bb = min(b, hi)
    if bb <= aa:
        return None
    return aa, bb

def _force_on_interval(A, B, a, b):
    return A*(b - a) + 0.5*B*(b*b - a*a)

def _moment_about_zref_on_interval(A, B, a, b, zref):
    return (
        A*zref*(b - a)
        + 0.5*B*zref*(b*b - a*a)
        - 0.5*A*(b*b - a*a)
        - (1.0/3.0)*B*(b*b*b - a*a*a)
    )

def _integrate_force(segs, z_lo, z_hi):
    if not segs:
        return 0.0
    F = 0.0
    for s in segs:
        rng = _clip(s["zt"], s["zb"], z_lo, z_hi)
        if rng is None:
            continue
        a, b = rng
        F += _force_on_interval(s["A"], s["B"], a, b)
    return F

def _integrate_moment_about(segs, z_lo, z_hi, zref):
    if not segs:
        return 0.0
    M = 0.0
    for s in segs:
        rng = _clip(s["zt"], s["zb"], z_lo, z_hi)
        if rng is None:
            continue
        a, b = rng
        M += _moment_about_zref_on_interval(s["A"], s["B"], a, b, zref)
    return M

rows_active, rows_p, (zA,pA_dn,pA_up), (zP,pP_dn,pP_up), z_toe = build_rows_for_d(d_star)
rows_hL, (zHL,uL_dn,uL_up) = build_hydro_rows_side(z_wL, z_toe, gamma_w)
rows_hR, (zHR,uR_dn,uR_up) = build_hydro_rows_side(z_wt, z_toe, gamma_w)

segs_active  = _build_segments(rows_active, z_key=zA,  p_top_key=pA_dn, p_bot_key=pA_up, factor=gamma_G_unfav)  # 0 → z
segs_passive = _build_segments(rows_p,      z_key=zP,  p_top_key=pP_dn, p_bot_key=pP_up, factor=gamma_G_unfav)  # Z → z
segs_hR      = _build_segments(rows_hR,     z_key=zHR, p_top_key=uR_dn, p_bot_key=uR_up, factor=gamma_G_unfav)  # z_wt → z
segs_hL      = _build_segments(rows_hL,     z_key=zHL, p_top_key=uL_dn, p_bot_key=uL_up, factor=gamma_G_unfav)  # z_wL → z

def _shear_at(z):
    Fa  = _integrate_force(segs_active,  z_lo=0.0,  z_hi=z)
    Fp  = _integrate_force(segs_passive, z_lo=Z,    z_hi=z)
    FwR = _integrate_force(segs_hR,      z_lo=z_wt, z_hi=z)
    FwL = _integrate_force(segs_hL,      z_lo=z_wL, z_hi=z)
    return (Fa + FwR) - (Fp + FwL)  # positive = right-to-left

z_lo = Z
z_hi = z_toe
S_lo = _shear_at(z_lo)
S_hi = _shear_at(z_hi)

if S_lo * S_hi > 0:
    grid = np.linspace(z_lo, z_hi, 61)
    vals = [_shear_at(z) for z in grid]
    idx  = None
    for j in range(len(grid)-1):
        if vals[j]*vals[j+1] <= 0:
            idx = j
            break
    if idx is not None:
        z_lo, z_hi = grid[idx], grid[idx+1]
        S_lo, S_hi = vals[idx], vals[idx+1]

for _ in range(80):
    z_mid = 0.5*(z_lo + z_hi)
    S_mid = _shear_at(z_mid)
    if abs(S_mid) < 1e-6 or (z_hi - z_lo) < 1e-6:
        break
    if S_lo * S_mid <= 0:
        z_hi, S_hi = z_mid, S_mid
    else:
        z_lo, S_lo = z_mid, S_mid

z_zero_shear = 0.5*(z_lo + z_hi)         # depth from right ground surface

M_active  = _integrate_moment_about(segs_active,  z_lo=0.0,  z_hi=z_zero_shear, zref=z_zero_shear)
M_passive = _integrate_moment_about(segs_passive, z_lo=Z,    z_hi=z_zero_shear, zref=z_zero_shear)
M_hR      = _integrate_moment_about(segs_hR,      z_lo=z_wt, z_hi=z_zero_shear, zref=z_zero_shear)
M_hL      = _integrate_moment_about(segs_hL,      z_lo=z_wL, z_hi=z_zero_shear, zref=z_zero_shear)
M_a_S = M_active + M_hR
M_p_S = M_passive + M_hL
M_max = M_a_S - M_p_S

z_grid = np.linspace(0.0, z_toe, 300)

M_z = np.array([
      _integrate_moment_about(segs_active,  z_lo=0.0,  z_hi=z, zref=z)
    + _integrate_moment_about(segs_hR,      z_lo=z_wt, z_hi=z, zref=z)
    - _integrate_moment_about(segs_passive, z_lo=Z,    z_hi=z, zref=z)
    - _integrate_moment_about(segs_hL,      z_lo=z_wL, z_hi=z, zref=z)
    for z in z_grid
])

V_z = np.array([_shear_at(z) for z in z_grid])

iM = int(np.argmax(np.abs(M_z)))
iV = int(np.argmax(np.abs(V_z)))
Mabs_max, z_Mmax = M_z[iM], z_grid[iM]
Vabs_max, z_Vmax = V_z[iV], z_grid[iV]

M_abs_max = max(np.max(np.abs(M_z)), 1e-9)
scale_M   = 0.45 * block_w / M_abs_max
x_base    = x_face_right
x_curve   = x_base + M_z * scale_M

ax.plot([x_base, x_base], [Z, -d_star], linestyle=":", color="gray", lw=1)
ax.plot(x_curve, Z - z_grid, color="black", lw=2, label="Factored M(z)")
ax.fill_betweenx(Z - z_grid, x_base, x_curve, color="grey", alpha=0.30)

ax.plot([x_curve[iM]], [Z - z_Mmax], marker="o", ms=5, color="black", zorder=25)
ax.text(x_curve[iM] + 0.15, Z - z_Mmax, f"M_max = {Mabs_max:.2f} kN·m/m", fontsize=8, ha="left", va="center")

ax.set_aspect("equal", adjustable="box")
ax.set_xlim(-10, 10)
ax.set_ylim(-d_star, Z)
ax.axis("off")

print("\n=== Factored Resultants & Envelopes (γ_G on earth; γ_G on hydro) ===")
print(f"Embedment (d*): {d_star:.3f} m ; Toe depth z_toe = {z_toe:.3f} m")
print(f"Zero-shear depth z_S: {z_zero_shear:.3f} m (below ground), {z_zero_shear - Z:.3f} m below dredge")
print(f"Max |Shear|  : {Vabs_max:+.3f} kN/m at z = {z_Vmax:.3f} m")
print(f"Max |Moment| : {Mabs_max:+.3f} kN·m/m at z = {z_Mmax:.3f} m")
print(f"At z_S:  M_a(S) = {M_a_S:.3f}  ;  M_p(S) = {M_p_S:.3f}  ⇒  M_max = {M_max:.3f} kN·m/m")

df_S = pd.DataFrame([
    {"Quantity": "Depth below ground [m]",            "Value": z_zero_shear},
    {"Quantity": "Depth below dredge [m]",            "Value": z_zero_shear - Z},
    {"Quantity": "M_a,soil(S) [kN·m/m]",              "Value": M_active},
    {"Quantity": "M_wR(S) [kN·m/m]",                  "Value": M_hR},
    {"Quantity": "M_a(S) = M_a,soil + M_wR [kN·m/m]", "Value": M_a_S},
    {"Quantity": "M_p,soil(S) [kN·m/m]",              "Value": M_passive},
    {"Quantity": "M_wL(S) [kN·m/m]",                  "Value": M_hL},
    {"Quantity": "M_p(S) = M_p,soil + M_wL [kN·m/m]", "Value": M_p_S},
    {"Quantity": "M_max = M_a(S) − M_p(S) [kN·m/m]",  "Value": M_max},
])
display(df_S.style.format({"Value": "{:.3f}"}))
\end{lstlisting}

\section{Shear line $t = 10.172$ meters}

\begin{lstlisting}[language=Python]
# DA1-2

V_abs_max = max(np.max(np.abs(V_z)), 1e-9)
scale_V   = 0.35 * block_w / V_abs_max

x_base_V  = x_face_left
x_curve_V = x_base_V - V_z * scale_V

ax.plot([x_base_V, x_base_V], [Z, -d_star], linestyle=":", color="gray", lw=1)
ax.plot(x_curve_V, Z - z_grid, color="black", lw=2, label="Factored V(z)")
ax.fill_betweenx(Z - z_grid, x_curve_V, x_base_V, color="grey", alpha=0.30)

xS, yS = np.interp(z_zero_shear, z_grid, x_curve_V), Z - z_zero_shear

xV, yV = x_curve_V[iV], Z - z_Vmax
ax.plot([xV], [yV], marker="s", ms=5, color="black", zorder=26)
ax.text(xV - 0.15, yV, f"|V|_max = {Vabs_max:.2f} kN/m", fontsize=8, ha="right", va="center")

ax.set_aspect("equal", adjustable="box")
ax.set_xlim(-10, 10)
ax.set_ylim(-d_star, Z)
ax.axis("off")

ax.set_aspect("equal", adjustable="box")
ax.set_xlim(-10, 10)
ax.set_ylim(-d_star, Z)
ax.axis("off")

def Va(z):  return _integrate_force(segs_active,  z_lo=0.0,  z_hi=z)
def Vp(z):  return _integrate_force(segs_passive, z_lo=Z,    z_hi=z)
def VwR(z): return _integrate_force(segs_hR,      z_lo=z_wt, z_hi=z)
def VwL(z): return _integrate_force(segs_hL,      z_lo=z_wL, z_hi=z)
def Vtot(z): return (Va(z) + VwR(z)) - (Vp(z) + VwL(z))

V_ground   = Vtot(0.0)
V_dredge   = Vtot(Z)
V_S        = Vtot(z_zero_shear)   # should be ~ 0
V_toe      = Vtot(z_toe)

Va_S, VwR_S = Va(z_zero_shear), VwR(z_zero_shear)
Vp_S, VwL_S = Vp(z_zero_shear), VwL(z_zero_shear)

df_V = pd.DataFrame([
    {"Quantity": "Zero-shear depth z_S [m]",            "Value": z_zero_shear},
    {"Quantity": "Depth below dredge at z_S [m]",       "Value": z_zero_shear - Z},
    {"Quantity": "V(0) at ground [kN/m]",               "Value": V_ground},
    {"Quantity": "V(Z) at dredge [kN/m]",               "Value": V_dredge},
    {"Quantity": "V(z_S) [kN/m]",                        "Value": V_S},
    {"Quantity": "V(z_toe) [kN/m]",                      "Value": V_toe},
    {"Quantity": "|V|_max [kN/m]",                       "Value": Vabs_max},
    {"Quantity": "Depth of |V|_max [m]",                 "Value": z_Vmax},

    # Component check at zero-shear (sums on each side should match)
    {"Quantity": "Va(0→z_S) [kN/m]",                     "Value": Va_S},
    {"Quantity": "VwR(wt→z_S) [kN/m]",                   "Value": VwR_S},
    {"Quantity": "Vp(Z→z_S) [kN/m]",                     "Value": Vp_S},
    {"Quantity": "VwL(wl→z_S) [kN/m]",                   "Value": VwL_S},
    {"Quantity": "Left-to-right sum @ z_S [kN/m]",       "Value": (Va_S + VwR_S) - (Vp_S + VwL_S)},  # ~ 0
])

display(df_V.style.format({"Value": "{:.3f}"}))
\end{lstlisting}

