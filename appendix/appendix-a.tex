\chapter{Python Code}
%\label{chapter:title}

Python code used for designing the structural solution to bank erosion can be found here.

%\emph{Adding source code to your report/thesis is supported with the package {\normalfont\texttt{listings}}. An example can be found below. Files can be added using {\normalfont\texttt{\textbackslash lstinputlisting[language=<language>]\{<filename>\}}}.}

\begin{comment}
\begin{lstlisting}[language=Python]
"""
ISA Calculator: import the function, specify the height and it will return a
list in the following format: [Temperature,Density,Pressure,Speed of Sound].
Note that there is no check to see if the maximum altitude is reached.
"""

import math
g0 = 9.80665
R = 287.0
layer1 = [0, 288.15, 101325.0]
alt = [0,11000,20000,32000,47000,51000,71000,86000]
a = [-.0065,0,.0010,.0028,0,-.0028,-.0020]

def atmosphere(h):
    for i in range(0,len(alt)-1):
        if h >= alt[i]:
            layer0 = layer1[:]
            layer1[0] = min(h,alt[i+1])
            if a[i] != 0:
                layer1[1] = layer0[1] + a[i]*(layer1[0]-layer0[0])
                layer1[2] = layer0[2] * (layer1[1]/layer0[1])**(-g0/(a[i]*R))
            else:
                layer1[2] = layer0[2]*math.exp((-g0/(R*layer1[1]))*(layer1[0]-layer0[0]))
    return [layer1[1],layer1[2]/(R*layer1[1]),layer1[2],math.sqrt(1.4*R*layer1[1])]
\end{lstlisting}
\end{comment}

\section{Parameters}

\begin{lstlisting}[language=Python]
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
from dataclasses import dataclass
from typing import Optional, Tuple, List
from io import StringIO

params = dict(
    # Geometry
    Z=4.0,                # Retained height (Z)
    t=6.0,                 # Embedment depth (t)
    alpha_deg=0.0,         # α: wall inclination with vertical (deg)
    beta_left_deg=0.0,     # β (left): ground slope near toe (deg)
    beta_right_deg=0.0,    # β (right/top): ground slope (deg)
    wall_thickness=0.05,    # visual wall thickness
    water_table_depth=1.47,   # water table depth
    water_level = 2.36,

    # Dimension placement
    dim_offset=4,            # horizontal offset (to the right of wall) for Z and t dimensions
    figsize=(16, 10),        # bigger figure to avoid overlap      
    layer_block_width=9.0,   # wider stratigraphy block
    min_layer_thk_for_params=1.1,  # only print γ,c,φ if layer is at least this thick [m]
)

COMMON_X_MIN = -12
COMMON_X_MAX = params["dim_offset"] + params["layer_block_width"]
COMMON_Y_MIN = -params["t"]
COMMON_Y_MAX = params["Z"]
fs=8

LINE_BREAK = chr(10)

def apply_common_axes(ax):
    ax.set_aspect("equal", adjustable="box")
    ax.set_xlim(COMMON_X_MIN, COMMON_X_MAX)
    ax.set_ylim(COMMON_Y_MIN, COMMON_Y_MAX)
\end{lstlisting}

\section{Geometry of the profile}

\begin{lstlisting}[language=Python]
def rot2d(points, angle_deg):
    a = np.deg2rad(angle_deg)
    R = np.array([[np.cos(a), -np.sin(a)], [np.sin(a),  np.cos(a)]])
    return (R @ points.T).T

def draw_arrow(ax, start, vec, head_width=0.25, head_length=0.4, lw=2):
    ax.arrow(start[0], start[1], vec[0], vec[1],
             length_includes_head=True, head_width=head_width,
             head_length=head_length, color="red", linewidth=lw)

def draw_dimension(ax, x, y0, y1, text, fs):
    """Vertical double-headed dimension with text placed to the right."""
    # Double-headed arrow
    ax.annotate('', xy=(x, y1), xytext=(x, y0),
                arrowprops=dict(arrowstyle='<->', color='black', linewidth=1.8))
    ymid = 0.5*(y0 + y1)
    ax.text(x + 0.35, ymid, text, rotation=90, va='center', fontsize=fs, color='black')

def label_horizontal_line(ax, y, text, x=-11.5, fs=fs, offset_pts=6):
    """Label a horizontal line at y with a small upward screen-space offset."""
    ax.annotate(text, xy=(x, y), xytext=(0, offset_pts),
                textcoords='offset points', ha='left', va='bottom', fontsize=fs, color='black')

Z       = params["Z"]
t       = params["t"]
alpha   = params["alpha_deg"]
betaL   = params["beta_left_deg"]
betaR   = params["beta_right_deg"]
delta   = params["delta_deg"]
wall_th = params["wall_thickness"]
fs      = params["font_size"]

fig, ax = plt.subplots(figsize=params["figsize"])

# Reference horizontal (dashed) through toe at y=0
# ax.plot([-5, 0], [0, 0], linestyle="--", linewidth=1.5, color="black")
# ax.plot([0, 5], [Z, Z], linestyle="--", linewidth=1.5, color="black")
label_horizontal_line(ax, Z, "Ground Surface [+2.5]", x=0.25, fs=8, offset_pts=6)
label_horizontal_line(ax, 0.0, "Dredge Level [-1.5]",  x=-4, fs=8, offset_pts=6)

# Water table depth
ax.plot([0, 4], [Z - params["water_table_depth"], Z - params["water_table_depth"]], linestyle="--", linewidth=1.5, color="black")
label_horizontal_line(ax, Z - params["water_table_depth"], "GWT [+1.03]", x=0.25, fs=8, offset_pts=6)

# Water level
ax.plot([-4, 0], [Z - params["water_level"], Z - params["water_level"]], linestyle="--", linewidth=1.5, color="black")
label_horizontal_line(ax, Z - params["water_level"], "WL [+0.14]", x=-4, fs=8, offset_pts=6)

# Wall direction
theta_wall = 90.0 - alpha
u = np.array([np.cos(np.deg2rad(theta_wall)), np.sin(np.deg2rad(theta_wall))])
toe  = np.array([0.0, 0.0])
top  = toe + u * Z
base = toe - u * t
n = np.array([-u[1], u[0]])

# Wall polygon (thick)
p1 = top  + n * (wall_th/2)
p2 = base + n * (wall_th/2)
p3 = base - n * (wall_th/2)
p4 = top  - n * (wall_th/2)
ax.plot([p1[0], p2[0], p3[0], p4[0], p1[0]],
        [p1[1], p2[1], p3[1], p4[1], p1[1]], color="black", linewidth=3)
# ax.fill_betweenx([COMMON_Y_MIN, COMMON_Y_MAX], p2[0], p3[0], color="black", zorder=0)

# Left ground (through toe) and right ground (through top)
len_ground = params['dim_offset']
left_end = np.array([-len_ground, -np.tan(np.deg2rad(betaL)) * len_ground])
right_end = top + np.array([len_ground, np.tan(np.deg2rad(betaR)) * len_ground])
# attach left ground to the left face of the wall (at toe level)
left_attach = toe + n * (wall_th/2)
ax.plot([left_attach[0], left_end[0]], [left_attach[1], left_end[1]], linewidth=3, color="black")
ax.plot([top[0], right_end[0]], [top[1], right_end[1]], linewidth=3, color="black")

dim_x = max(top[0], p1[0], p4[0]) + params["dim_offset"]
draw_dimension(ax, 2.5, 0.0, top[1], f"Z = {Z:g} m", 8)
draw_dimension(ax, 2.5, -t, 0.0, f"t = {t:g} m", 8)
draw_dimension(ax, 4, Z - params["water_table_depth"], Z, f"$Z_{{2}} = {params['water_table_depth']:g}$ m", 8)
draw_dimension(ax, 4, 0.0, Z - params["water_table_depth"], f"$Z_{{1}} = {Z - params['water_table_depth']:g}$ m", 8)

# Wall face & scaling
x_wall = top[0] + 0.3
block_w = params["dim_offset"]
target  = 0.40 * block_w

half_span = max(abs(COMMON_X_MIN - x_wall), abs(COMMON_X_MAX - x_wall))
ax.set_xlim(x_wall - half_span, x_wall + half_span)
ax.set_ylim(COMMON_Y_MIN, COMMON_Y_MAX + 1)

# position the axes in the middle of the figure canvas
dw = desired_width if 'desired_width' in globals() else 0.6
dh = desired_height if 'desired_height' in globals() else 0.8
left = (1.0 - dw) / 2.0
bottom = (1.0 - dh) / 2.0
ax.set_position([left, bottom, dw, dh])

ax.axis("off")
plt.show()
\end{lstlisting}

\section{Soil profile}

\begin{lstlisting}[language=Python]
@dataclass
class SoilParams:
    unit_weight: Optional[float] = None    # γ [kN/m³]
    cohesion: Optional[float] = None       # c [kPa]
    phi: Optional[float] = None            # φ [°]
    delta: Optional[float] = None          # δ [°]
    k_subgrade: Optional[float] = None     # k [kN/m³]
    modulus_E: Optional[float] = None      # E [MPa]
    permeability_k: Optional[float] = None # kperm [m/s]
    unit_weight_sat: Optional[float] = None  # γ_sat [kN/m³]

@dataclass
class Layer:
    name: str
    top_depth: float         # depth from right ground surface, positive downward [m]
    bottom_depth: float      # depth from right ground surface, positive downward [m]
    params: SoilParams
    color: str = "#dddddd"

layers: List[Layer] = [
    Layer("Fill",             0.0,   2.0,  SoilParams(unit_weight=12.0, cohesion=20, phi=15.0, unit_weight_sat=12.0)),
    Layer("Fine–Medium Sand", 2.0,   7.0,  SoilParams(unit_weight=17.0, cohesion=0,  phi=30,   unit_weight_sat=19.0)),
    Layer("Clay",             7.0,  10.0,  SoilParams(unit_weight=14.0, cohesion=25, phi=17.5, unit_weight_sat=14.0)),
    Layer("Clayey Sand",     10.0,  15.0,  SoilParams(unit_weight=18.0, cohesion=0,  phi=25,   unit_weight_sat=20.0)),
    Layer("Clay",            15.0,  16.0,  SoilParams(unit_weight=14.0, cohesion=25, phi=17.5, unit_weight_sat=14.0)),
    Layer("Clayey Sand",     16.0,  17.5,  SoilParams(unit_weight=18.0, cohesion=0,  phi=25,   unit_weight_sat=20.0)),
    Layer("Medium Sand",     17.5,  32.5,  SoilParams(unit_weight=18.0, cohesion=0,  phi=32.5, unit_weight_sat=20.0)),
]

def rot2d(points, angle_deg):
    a = np.deg2rad(angle_deg)
    R = np.array([[np.cos(a), -np.sin(a)], [np.sin(a),  np.cos(a)]])
    return (R @ points.T).T

def draw_arrow(ax, start, vec, head_width=0.25, head_length=0.4, lw=2, color="red"):
    ax.arrow(start[0], start[1], vec[0], vec[1],
             length_includes_head=True, head_width=head_width,
             head_length=head_length, color=color, linewidth=lw)

def draw_P_arrows_perp_to_segment(ax, A, B, n_arrows, length, fs, label, offset=1.35, color="red"):
    # Skip drawing if "length" is 0 or negative (P=0 rule)
    if n_arrows <= 0 or length <= 0:
        return
    A = np.array(A, dtype=float)
    B = np.array(B, dtype=float)
    seg = B - A
    L = np.linalg.norm(seg)
    if L == 0:
        return
    s = seg / L
    n1 = np.array([-s[1], s[0]])
    n_out = n1 if n1[1] >= 0 else -n1
    ts = np.linspace(0.1, 0.9, n_arrows)
    tips = [A + t * seg for t in ts]
    for tip in tips:
        start = tip + n_out * length
        ax.arrow(start[0], start[1],
                 (-n_out * length)[0], (-n_out * length)[1],
                 length_includes_head=True,
                 head_width=0.25, head_length=0.4,
                 color=color, linewidth=2)
    # place label a bit above the arrows
    mid_tip = tips[len(tips)//2]
    label_pos = mid_tip + n_out * (offset * length)
    ax.text(label_pos[0], label_pos[1], label,
            fontsize=fs, ha="center", va="bottom", color="black")

def draw_dimension(ax, x, y0, y1, text, fs):
    ax.annotate('', xy=(x, y1), xytext=(x, y0),
                arrowprops=dict(arrowstyle='<->', color='black', linewidth=1.8))
    ymid = 0.5*(y0 + y1)
    ax.text(x + 0.5, ymid, text, rotation=90, va='center', fontsize=fs, color='black')

def draw_layers_right_dashed(ax, top_point, block_width, layers,
                             fs=fs, show_params=True, min_thk=0.5,
                             dash_pattern=(6, 4), max_depth=None):
    """
    Draw soil layers to the RIGHT of the wall using ONLY dashed horizontal lines.
    - Layer name centered in the layer
    - Only γ, c, φ printed under the name (and only if the layer is thick enough)
    """
    x0, y_top = top_point
    xL = x0 
    xR = xL + params['dim_offset']

    # ----- decide depth limit
    if max_depth is None:
        max_depth = max(lyr.bottom_depth for lyr in layers)

    # ----- build a clipped list of layers
    clipped = []
    for lyr in layers:
        if lyr.top_depth >= max_depth:
            continue
        top_d = lyr.top_depth
        bot_d = min(lyr.bottom_depth, max_depth)
        if bot_d - top_d <= 1e-9:
            continue
        # keep same params/color
        clipped.append(Layer(lyr.name, top_d, bot_d, lyr.params, lyr.color))

    # --- draw dashed boundaries for all unique layer interfaces
    boundaries = []
    for lyr in layers:
        boundaries.append(y_top - lyr.top_depth)
        boundaries.append(y_top - lyr.bottom_depth)

    boundaries = sorted(boundaries)
    eps = 1e-6
    last = None
    for y in boundaries:
        if last is None or abs(y - last) > eps:
            ax.plot([xL, xR], [y, y],
                    linestyle=(0, dash_pattern), linewidth=1.2, color="black")
            last = y

    # --- labels at TOP (lock to dashed line; use screen offsets)
    for lyr in layers:
        y1 = y_top - lyr.top_depth      # top boundary of layer (dashed line)
        y2 = y_top - lyr.bottom_depth
        h  = y1 - y2
        xc = (xL + xR) / 2.0

    # screen-space paddings (points) so distance from the dashed line is consistent
        name_pad_pts = 6       # distance below dashed line to the name
        gap_pts      = 8       # extra gap from name to parameters

    # 1) Layer name (anchored to the top line, offset downward in points)
        ax.annotate(
            lyr.name, xy=(xc, y1), xytext=(0, -name_pad_pts),
            textcoords='offset points', ha='center', va='top', fontsize=8, color='black'
    )

    # 2) Parameters (γ, c, φ) under the name for EVERY layer
        if show_params and h >= 3:
            sp = lyr.params
            lines = []
            if sp.unit_weight is not None: lines.append(f"γₖ = {sp.unit_weight:g} kN/m³")
            if sp.unit_weight_sat is not None: lines.append(f"γₛ = {sp.unit_weight_sat:g} kN/m³")
            if sp.cohesion    is not None: lines.append(f"cᵤ = {sp.cohesion:g} kPa")
            if sp.phi         is not None: lines.append(f"φₖ = {sp.phi:g}°")
            if lines:
                ax.annotate(
                    LINE_BREAK.join(lines), xy=(xc, y1),
                    xytext=(0, -(name_pad_pts + gap_pts)),
                    textcoords='offset points', ha='center', va='top',
                    fontsize=8, color='black'
            )

def place_force_label(ax, start, vec, text, fs, pad=0.8):
    """
    Put a label near the arrow but offset perpendicular to the arrow vector
    so the text doesn't sit on the wall/layers.
    """
    v = np.array(vec, dtype=float)
    nv = np.linalg.norm(v)
    if nv == 0:  # fallback
        ax.text(start[0], start[1], text, fontsize=10, color="black")
        return
    vhat = v / nv
    p = np.array([-vhat[1], vhat[0]])
    anchor = np.array(start) + v * 0.55 + p * pad
    ax.text(anchor[0], anchor[1], text, fontsize=10, color="black",
            ha="center", va="bottom")

Z       = params["Z"]
t       = params["t"]
alpha   = params["alpha_deg"]
betaL   = params["beta_left_deg"]
betaR   = params["beta_right_deg"]
delta   = params["delta_deg"]
wall_th = params["wall_thickness"]
fs      = params["font_size"]

fig, ax = plt.subplots(figsize=params["figsize"])

# Reference horizontal (dashed) through toe at y=0
label_horizontal_line(ax, Z, "Ground Surface [+2.5]", x=0.25, fs=8, offset_pts=6)
label_horizontal_line(ax, 0.0, "Dredge Level [-1.5]",  x=-4, fs=8, offset_pts=6)

# Water table depth
ax.plot([0, 4], [Z - params["water_table_depth"], Z - params["water_table_depth"]], linestyle="--", linewidth=1.5, color="black")
label_horizontal_line(ax, Z - params["water_table_depth"], "GWT [+1.03]", x=0.25, fs=8, offset_pts=6)

# Water level
ax.plot([-4, 0], [Z - params["water_level"], Z - params["water_level"]], linestyle="--", linewidth=1.5, color="black")
label_horizontal_line(ax, Z - params["water_level"], "WL [+0.14]", x=-4, fs=8, offset_pts=6)

# Wall direction
theta_wall = 90.0 - alpha
u = np.array([np.cos(np.deg2rad(theta_wall)), np.sin(np.deg2rad(theta_wall))])
toe  = np.array([0.0, 0.0])
top  = toe + u * Z
base = toe - u * t
n = np.array([-u[1], u[0]])

# Wall polygon
p1 = top  + n * (wall_th/2)
p2 = base + n * (wall_th/2)
p3 = base - n * (wall_th/2)
p4 = top  - n * (wall_th/2)
ax.plot([p1[0], p2[0], p3[0], p4[0], p1[0]],
        [p1[1], p2[1], p3[1], p4[1], p1[1]], color="black", linewidth=3)

len_ground = params['dim_offset']
left_end = np.array([-len_ground, -np.tan(np.deg2rad(betaL)) * len_ground])
right_end = top + np.array([len_ground, np.tan(np.deg2rad(betaR)) * len_ground])
left_attach = toe + n * (wall_th/2)
ax.plot([left_attach[0], left_end[0]], [left_attach[1], left_end[1]], linewidth=3, color="black")
ax.plot([top[0], right_end[0]], [top[1], right_end[1]], linewidth=3, color="black")

draw_layers_right_dashed(
    ax, top_point=top, block_width=params["dim_offset"], layers=layers,
    fs=max(12, params["font_size"]-2), show_params=True,
    min_thk=params["min_layer_thk_for_params"],
    max_depth=params["Z"] + params["t"]  # plot from right ground down to Z+T
)

half_span = max(abs(COMMON_X_MIN - x_wall), abs(COMMON_X_MAX - x_wall))
ax.set_xlim(x_wall - half_span, x_wall + half_span)
ax.set_ylim(COMMON_Y_MIN, COMMON_Y_MAX + 1)

dw = desired_width if 'desired_width' in globals() else 0.6
dh = desired_height if 'desired_height' in globals() else 0.8
left = (1.0 - dw) / 2.0
bottom = (1.0 - dh) / 2.0
ax.set_position([left, bottom, dw, dh])

ax.axis("off")
plt.show()
\end{lstlisting}

\section{Vertical effective stress}

\begin{lstlisting}[language=Python]
def layer_at(z_mid, layers):
    for L in layers:
        if L.top_depth <= z_mid < L.bottom_depth:
            return L
    return layers[-1]

def seg_gamma_eff(L, z1, z2, z_wt, gamma_w=9.81):
    # segment does not cross GWT (we'll ensure nodes include WT)
    if z2 <= z_wt:
        return float(L.params.unit_weight or 0.0)
    else:
        if L.params.unit_weight_sat is not None:
            return float(L.params.unit_weight_sat) - gamma_w
        return float(L.params.unit_weight or 0.0) - gamma_w

Z = float(params["Z"])
t = float(params["t"])
block_w = float(params["dim_offset"])
xL_face = float(x_face_left)   # left face (passive side)
xR_face = float(x_face_right)  # right face (active side)

z_wt = float(params["water_table_depth"])
max_depth = float(Z + t)  # toe depth in absolute coordinates

z_top_L = Z
z_bot_L = Z + t
nodes_L = {z_top_L, z_bot_L}
if z_top_L < z_wt < z_bot_L:
    nodes_L.add(z_wt)
for L in layers:
    if z_top_L <= L.top_depth    <= z_bot_L: nodes_L.add(L.top_depth)
    if z_top_L <= L.bottom_depth <= z_bot_L: nodes_L.add(L.bottom_depth)
z_nodes_L = sorted(nodes_L)

sv_L = [0.0]
for i in range(1, len(z_nodes_L)):
    z1, z2 = z_nodes_L[i-1], z_nodes_L[i]
    Lseg = layer_at((z1+z2)/2.0, layers)
    gamma = seg_gamma_eff(Lseg, z1, z2, z_wt)
    sv_L.append(sv_L[-1] + gamma * (z2 - z1))
z_sv_L = np.array(z_nodes_L)
sv_L = np.array(sv_L)

target_L = 0.40 * block_w
pmax_L = float(np.max(sv_L)) if sv_L.size else 0.0
scale_L = (target_L / pmax_L) if pmax_L > 1e-12 else 0.0
y_L = Z - z_sv_L
x_L = xL_face - sv_L * scale_L

z_top_R = 0.0
nodes_R = {z_top_R, min(z_wt, max_depth), max_depth}
for L in layers:
    if L.top_depth  <= max_depth: nodes_R.add(max(0.0, L.top_depth))
    if L.bottom_depth <= max_depth: nodes_R.add(max(0.0, L.bottom_depth))
z_nodes_R = sorted(nodes_R)

sv_R = [0.0]
for i in range(1, len(z_nodes_R)):
    z1, z2 = z_nodes_R[i-1], z_nodes_R[i]
    Lseg = layer_at((z1+z2)/2.0, layers)
    gamma = seg_gamma_eff(Lseg, z1, z2, z_wt)
    sv_R.append(sv_R[-1] + gamma * (z2 - z1))
z_sv_R = np.array(z_nodes_R)
sv_R = np.array(sv_R)

target_R = 1 * block_w
pmax_R = float(np.max(sv_R)) if sv_R.size else 0.0
scale_R = (target_R / pmax_R) if pmax_R > 1e-12 else 0.0
y_R = Z - z_sv_R
x_R = xR_face + sv_R * scale_R

fig, ax = plt.subplots(figsize=params["figsize"])

try:
    ax.plot([p1[0], p2[0], p3[0], p4[0], p1[0]],
            [p1[1], p2[1], p3[1], p4[1], p1[1]], color="black", linewidth=3)
except NameError:
    # simple vertical line at x_wall
    x_wall = 0.0
    ax.plot([x_wall, x_wall], [Z, Z - t], color="black", linewidth=3)

left_end  = np.array([-params['dim_offset'], -np.tan(np.deg2rad(params['beta_left_deg'])) * params['dim_offset']])
right_end = np.array([params['dim_offset'], Z + np.tan(np.deg2rad(params['beta_right_deg'])) * params['dim_offset']])
toe = np.array([0.0, 0.0])
top = np.array([0.0, Z])
ax.plot([toe[0], left_end[0]], [toe[1], left_end[1]], linewidth=3, color="black")
ax.plot([top[0], right_end[0]], [top[1], right_end[1]], linewidth=3, color="black")

label_horizontal_line(ax, Z, "GS [+2.5]", x=2.25, fs=8, offset_pts=6)
label_horizontal_line(ax, 0.0, "DL [-1.5]",  x=-4, fs=8, offset_pts=6)

ax.plot([0, 4], [Z - params["water_table_depth"], Z - params["water_table_depth"]], linestyle="--", linewidth=1.5, color="black")
label_horizontal_line(ax, Z - params["water_table_depth"], "GWT [+1.03]", x=2.25, fs=8, offset_pts=6)

ax.plot([-4, 0], [Z - params["water_level"], Z - params["water_level"]], linestyle="--", linewidth=1.5, color="black")
label_horizontal_line(ax, Z - params["water_level"], "WL [+0.14]", x=-4, fs=8, offset_pts=6)

ax.plot(x_L, y_L, color="green", linewidth=2, label="σ′v")
ax.fill_betweenx(y_L, x_L, xL_face, color="green", alpha=0.25)

ax.plot(x_R, y_R, color="green", linewidth=2, label="σ′v")
ax.fill_betweenx(y_R, xR_face, x_R, color="green", alpha=0.25)

dy = 0.12  # vertical offset for labels
# simple value labels at key depths (interfaces)
for z in sorted(set(list(z_sv_L) + list(z_sv_R))):
    # left val if within left range
    if z_sv_L.min() <= z <= z_sv_L.max():
        sv_val = float(np.interp(z, z_sv_L, sv_L))
        y = Z - z
        x = xL_face - sv_val * scale_L
        ax.text(x - 0.03*block_w, y+dy, f"{sv_val:.1f} kN/m²", color="green", fontsize=8, ha="right", va="center")
    # right val if within right range
    if z_sv_R.min() <= z <= z_sv_R.max():
        sv_val = float(np.interp(z, z_sv_R, sv_R))
        y = Z - z
        x = xR_face + sv_val * scale_R
        ax.text(x + 0.03*block_w, y+dy, f"{sv_val:.1f} kN/m²", color="green", fontsize=8, ha="left", va="center")

draw_layers_right_dashed(
    ax,
    top_point=top,
    block_width=params["dim_offset"],
    layers=layers,
    fs=max(12, params["font_size"]-2),
    show_params=False,
    min_thk=params["min_layer_thk_for_params"]
)

x_wall_center = (xL_face + xR_face) / 2.0
half_span = max(abs(COMMON_X_MIN - x_wall_center), abs(COMMON_X_MAX - x_wall_center))
ax.set_xlim(x_wall_center - half_span, x_wall_center + half_span)
ax.set_ylim(COMMON_Y_MIN, COMMON_Y_MAX + 1)
dw = desired_width if 'desired_width' in globals() else 0.6
dh = desired_height if 'desired_height' in globals() else 0.8
left = (1.0 - dw) / 2.0
bottom = (1.0 - dh) / 2.0
ax.set_position([left, bottom, dw, dh])
ax.axis("off")
plt.show()

z_col = "z [m]" if "z [m]" in df_i.columns else "z"
sv_col = (
    "σ′v [kN/m²]" if "σ′v [kN/m²]" in df_i.columns
    else ("σ′v [kPa]" if "σ′v [kPa]" in df_i.columns else "sigma_v")
)

max_depth = float(Z + t)
z_wt = float(params["water_table_depth"])

df_right = df_i[[z_col, sv_col]].copy()
df_right = df_right[df_right[z_col] <= max_depth].sort_values(z_col).reset_index(drop=True)

if "df_sigma_left" in globals():
    df_left = df_sigma_left.copy().sort_values(z_col).reset_index(drop=True)
else:
    df_left = pd.DataFrame({z_col: z_sv_L, "σ′v_left [kN/m²]": sv_L}).sort_values(z_col).reset_index(drop=True)

left_sv_col = next(c for c in df_left.columns if c != z_col)
right_z = df_right[z_col].to_numpy()
right_sv = df_right[sv_col].to_numpy()
left_z = df_left[z_col].to_numpy()
left_sv = df_left[left_sv_col].to_numpy()

union_z = np.unique(np.concatenate([right_z, left_z, [z_wt] if (0 <= z_wt <= max_depth) else []]))
union_z = np.sort(union_z)

right_interp = np.interp(union_z, right_z, right_sv)
left_interp = np.interp(union_z, left_z, left_sv)

df_both = pd.DataFrame({
    "z [m]": union_z,
    "σ′v_left [kN/m²]": left_interp,
    "σ′v_right [kN/m²]": right_interp
})

from IPython.display import display
display(
    df_both.style.format({"z [m]": "{:.2f}", "σ′v_left [kN/m²]": "{:.2f}", "σ′v_right [kN/m²]": "{:.2f}"})
)
\end{lstlisting}

\section{Earth pressure and force}

\begin{lstlisting}[language=Python]
@dataclass
class SoilParams:
    unit_weight: Optional[float] = None    # γ [kN/m³]
    cohesion: Optional[float] = None       # c [kPa]
    phi: Optional[float] = None            # φ [°]
    delta: Optional[float] = None          # δ [°]
    k_subgrade: Optional[float] = None     # k [kN/m³]
    modulus_E: Optional[float] = None      # E [MPa]
    permeability_k: Optional[float] = None # kperm [m/s]
    unit_weight_sat: Optional[float] = None  # γ_sat [kN/m³]

@dataclass
class Layer:
    name: str
    top_depth: float         # depth from right ground surface, positive downward [m]
    bottom_depth: float      # depth from right ground surface, positive downward [m]
    params: SoilParams
    color: str = "#dddddd"

layers: List[Layer] = [
    Layer("Fill",             0.0,   2.0,  SoilParams(unit_weight=12.0, cohesion=20, phi=15.0, unit_weight_sat=12.0)),
    Layer("Fine–Medium Sand", 2.0,   7.0,  SoilParams(unit_weight=17.0, cohesion=0,  phi=30,   unit_weight_sat=19.0)),
    Layer("Clay",             7.0,  10.0,  SoilParams(unit_weight=14.0, cohesion=25, phi=17.5, unit_weight_sat=14.0)),
    Layer("Clayey Sand",     10.0,  15.0,  SoilParams(unit_weight=18.0, cohesion=0,  phi=25,   unit_weight_sat=20.0)),
    Layer("Clay",            15.0,  16.0,  SoilParams(unit_weight=14.0, cohesion=25, phi=17.5, unit_weight_sat=14.0)),
    Layer("Clayey Sand",     16.0,  17.5,  SoilParams(unit_weight=18.0, cohesion=0,  phi=25,   unit_weight_sat=20.0)),
    Layer("Medium Sand",     17.5,  32.5,  SoilParams(unit_weight=18.0, cohesion=0,  phi=32.5, unit_weight_sat=20.0)),
]

def label_horizontal_line(ax, y, text, x=0.0, fs=8, offset_pts=6):
    ax.annotate(text, xy=(x, y), xytext=(0, offset_pts),
                textcoords='offset points', ha='left', va='bottom', fontsize=fs, color='black')

def draw_layers_right_dashed(ax, top_point, block_width, layers,
                             fs=8, show_params=True, min_thk=0.5,
                             dash_pattern=(6, 4)):
    x0, y_top = top_point
    xL = x0
    xR = xL + block_width
    boundaries = []
    for lyr in layers:
        boundaries += [y_top - lyr.top_depth, y_top - lyr.bottom_depth]
    boundaries = sorted(list({round(b, 6) for b in boundaries}))
    for y in boundaries:
        ax.plot([xL, xR], [y, y], linestyle=(0, dash_pattern), linewidth=1.2, color="black")
    if not show_params:
        return
    for lyr in layers:
        y1 = y_top - lyr.top_depth
        y2 = y_top - lyr.bottom_depth
        h  = y1 - y2
        if h < min_thk: 
            continue
        xc = (xL + xR) / 2.0
        sp = lyr.params
        lines = []
        if sp.unit_weight is not None:     lines.append(f"γ = {sp.unit_weight:g} kN/m³")
        if sp.unit_weight_sat is not None: lines.append(f"γ_sat = {sp.unit_weight_sat:g} kN/m³")
        if sp.cohesion    is not None:     lines.append(f"c = {sp.cohesion:g} kPa")
        if sp.phi         is not None:     lines.append(f"φ = {sp.phi:g}°")
        if lines:
            ax.annotate("\n".join(lines), xy=(xc, y1),
                        xytext=(0, -12), textcoords='offset points',
                        ha='center', va='top', fontsize=6, color='black')

def compute_active_pressures_with_interfaces(
    layers, water_table_depth, gamma_w=9.81, surcharge_q=0.0
):
    """
    Returns piecewise-active profile and an interface dataframe (with GWT included).
    df_i columns include:
      - "z [m]", "σ′v [kN/m²]", "Ka↑", "Ka↓",
        "p↑ = Ka↑·σ′v [kN/m²]" (just above/bottom), "p↓ = Ka↓·σ′v [kN/m²]" (just below/top)
    """
    def Ka_of(phi_deg: float) -> float:
        if phi_deg is None: return 1.0
        a = np.deg2rad(45.0 - 0.5*phi_deg)
        return np.tan(a)**2

    z_wt = float(water_table_depth)

    # nodes for piecewise integration (include GWT)
    nodes = {0.0, z_wt}
    for L in layers:
        nodes.add(L.top_depth); nodes.add(L.bottom_depth)
    nodes = sorted(x for x in nodes if x >= 0.0)

    def layer_at(z_mid):
        for L in layers:
            if L.top_depth <= z_mid < L.bottom_depth:
                return L
        return layers[-1]

    def gamma_eff(L, z_top, z_bot):
        # segment will not cross GWT, nodes guarantee this
        if z_bot <= z_wt:  # above GWT
            return float(L.params.unit_weight or 0.0)
        else:              # below GWT
            if L.params.unit_weight_sat is not None:
                return float(L.params.unit_weight_sat) - gamma_w
            return float(L.params.unit_weight or 0.0) - gamma_w

    # Effective vertical stress at nodes (independent of Ka)
    sigma_v_at_node = {0.0: surcharge_q}
    for k in range(1, len(nodes)):
        zt, zb = nodes[k-1], nodes[k]
        Lseg = layer_at((zt+zb)/2.0)
        sigma_v_at_node[zb] = sigma_v_at_node[zt] + gamma_eff(Lseg, zt, zb) * (zb - zt)

    # Active lateral pressure accumulation over segments
    depths = [0.0]; pvals = [0.0]
    for k in range(1, len(nodes)):
        zt, zb = nodes[k-1], nodes[k]
        Lseg  = layer_at((zt+zb)/2.0)
        Ka    = Ka_of(Lseg.params.phi or 0.0)
        gamma = gamma_eff(Lseg, zt, zb)
        pvals.append(pvals[-1] + Ka * gamma * (zb - zt))
        depths.append(zb)

    # Interfaces (INCLUDE GWT explicitly so the jump is correct at z = z_wt)
    interfaces = []
    eps = 1e-9
    layer_bounds = sorted(
        ({L.bottom_depth for L in layers}
         | {L.top_depth for L in layers}
         | {z_wt})  # <— include water table as an interface depth
    )
    for zb in layer_bounds:
        if zb < 0.0:
            continue
        # σ′v at boundary
        if zb in sigma_v_at_node:
            sv = sigma_v_at_node[zb]
        else:
            # interpolate between neighbor nodes
            j = np.searchsorted(nodes, zb)
            z0, z1 = nodes[j-1], nodes[j]
            sv0, sv1 = sigma_v_at_node[z0], sigma_v_at_node[z1]
            sv = sv0 + (sv1 - sv0) * (zb - z0) / (z1 - z0)

        Labove = layer_at(max(zb - eps, 0.0))
        Lbelow = layer_at(zb + eps)
        Ka_above = Ka_of(Labove.params.phi or 0.0)
        Ka_below = Ka_of(Lbelow.params.phi or 0.0)

        interfaces.append(dict(
            z=zb,
            sigma_v=sv,
            Ka_above=Ka_above,
            Ka_below=Ka_below,
            p_from_above=Ka_above * sv,  # p just above/bottom (top side of interface)
            p_from_below=Ka_below * sv,  # p just below/top (bottom side of interface)
        ))

    df_i = pd.DataFrame(interfaces).sort_values("z").reset_index(drop=True)
    df_i = df_i.rename(columns={
        "z": "z [m]",
        "sigma_v": "σ′v [kN/m²]",
        "Ka_above": "Ka↑",
        "Ka_below": "Ka↓",
        "p_from_above": "p↑ = Ka↑·σ′v [kN/m²]",
        "p_from_below": "p↓ = Ka↓·σ′v [kN/m²]",
    })
    return np.array(depths), np.array(pvals), interfaces, df_i

def compute_passive_pressures_left_with_interfaces(
    layers, Z, t, water_table_depth, gamma_w=9.81, surcharge_q=0.0
):
    def Kp_of(phi_deg: Optional[float]):
        a = np.deg2rad(45.0 + 0.5*(phi_deg or 0.0))
        return np.tan(a)**2

    z_top = float(Z)
    z_toe = float(Z + t)
    z_wt  = float(water_table_depth)

    # nodes along left side (from dredge Z down to toe Z+t), include GWT if inside
    nodes = {z_top, z_toe}
    if z_top < z_wt < z_toe: nodes.add(z_wt)
    for L in layers:
        if z_top <= L.top_depth    <= z_toe: nodes.add(L.top_depth)
        if z_top <= L.bottom_depth <= z_toe: nodes.add(L.bottom_depth)
    nodes = sorted(nodes)

    def layer_at(z_mid):
        for L in layers:
            if L.top_depth <= z_mid < L.bottom_depth:
                return L
        return layers[-1]

    def gamma_eff(L, z1, z2):
        # segment won't cross GWT due to nodes
        if z2 <= z_wt:  # above GWT (shallower)
            return float(L.params.unit_weight or 0.0)
        else:           # below GWT
            if L.params.unit_weight_sat is not None:
                return float(L.params.unit_weight_sat) - gamma_w
            return float(L.params.unit_weight or 0.0) - gamma_w

    # Effective vertical stress at nodes (from top Z downward)
    sigma = [surcharge_q]
    for i in range(1, len(nodes)):
        z1, z2 = nodes[i-1], nodes[i]
        Lseg = layer_at((z1+z2)/2.0)
        sigma.append(sigma[-1] + gamma_eff(Lseg, z1, z2) * (z2 - z1))
    sigma = np.array(sigma)

    # Build interface table in same spirit as "active"
    recs = []
    eps = 1e-9
    for zb in nodes:
        sv = float(np.interp(zb, np.array(nodes), sigma))
        Labove = layer_at(max(zb - eps, z_top))
        Lbelow = layer_at(min(zb + eps, z_toe - eps))
        Kp_up  = Kp_of(Labove.params.phi)
        Kp_dn  = Kp_of(Lbelow.params.phi)
        recs.append(dict(
            z=zb, sigma_v_left=sv,
            Kp_up=Kp_up, Kp_dn=Kp_dn,
            p_up=Kp_up*sv, p_dn=Kp_dn*sv
        ))

    df = pd.DataFrame(recs).sort_values("z").reset_index(drop=True)
    df = df.rename(columns={
        "z": "z [m]",
        "sigma_v_left": "σ′v_left [kN/m²]",
        "Kp_up": "Kp↑",
        "Kp_dn": "Kp↓",
        "p_up": "p↑ = Kp↑·σ′v [kN/m²]",
        "p_dn": "p↓ = Kp↓·σ′v [kN/m²]",
    })
    return np.array(nodes), sigma, df

Z       = float(params["Z"])
t       = float(params["t"])
alpha   = float(params["alpha_deg"])
betaL   = float(params["beta_left_deg"])
betaR   = float(params["beta_right_deg"])
wall_th = float(params["wall_thickness"])
fs      = int(params["font_size"])
block_w = params["dim_offset"]

fig, ax = plt.subplots(figsize=params["figsize"])

label_horizontal_line(ax, Z, "GS [+2.5]", x=2.25, fs=8, offset_pts=6)
label_horizontal_line(ax, 0.0, "DL [-1.5]",  x=-4, fs=8, offset_pts=6)

ax.plot([0, 4], [Z - params["water_table_depth"], Z - params["water_table_depth"]], linestyle="--", linewidth=1.5, color="black")
label_horizontal_line(ax, Z - params["water_table_depth"], "GWT [+1.03]", x=2.25, fs=8, offset_pts=6)

ax.plot([-4, 0], [Z - params["water_level"], Z - params["water_level"]], linestyle="--", linewidth=1.5, color="black")
label_horizontal_line(ax, Z - params["water_level"], "WL [+0.14]", x=-4, fs=8, offset_pts=6)

theta_wall = 90.0 - alpha
uvec = np.array([np.cos(np.deg2rad(theta_wall)), np.sin(np.deg2rad(theta_wall))])
toe  = np.array([0.0, 0.0])
top  = toe + uvec * Z
base = toe - uvec * t
nvec = np.array([-uvec[1], uvec[0]])

p1 = top  + nvec * (wall_th/2)
p2 = base + nvec * (wall_th/2)
p3 = base - nvec * (wall_th/2)
p4 = top  - nvec * (wall_th/2)
ax.plot([p1[0], p2[0], p3[0], p4[0], p1[0]],
        [p1[1], p2[1], p3[1], p4[1], p1[1]], color="black", linewidth=3)

left_end  = np.array([-block_w, -np.tan(np.deg2rad(betaL)) * block_w])
right_end = top + np.array([block_w, np.tan(np.deg2rad(betaR)) * block_w])
ax.plot([toe[0], left_end[0]],  [toe[1], left_end[1]],  linewidth=3, color="black")
ax.plot([top[0], right_end[0]], [top[1], right_end[1]], linewidth=3, color="black")

draw_layers_right_dashed(
    ax, top_point=top, block_width=block_w, layers=layers,
    fs=max(12, params["font_size"]-2), show_params=False,
    min_thk=params["min_layer_thk_for_params"]
)

x_face_left  = min(p1[0], p2[0], p3[0], p4[0])
x_face_right = max(p1[0], p2[0], p3[0], p4[0])
z_top = Z
z_toe = Z + t

depths, pa, interfaces, df_i = compute_active_pressures_with_interfaces(
    layers, water_table_depth=z_wt, gamma_w=9.81
)
z_col  = "z [m]" if "z [m]" in df_i.columns else "z"
sv_col = "σ′v [kN/m²]" if "σ′v [kN/m²]" in df_i.columns else "sigma_v"
p_up_c = "p↑ = Ka↑·σ′v [kN/m²]" if "p↑ = Ka↑·σ′v [kN/m²]" in df_i.columns else "p_from_above"
p_dn_c = "p↓ = Ka↓·σ′v [kN/m²]" if "p↓ = Ka↓·σ′v [kN/m²]" in df_i.columns else "p_from_below"

rows_df = df_i[df_i[z_col] <= z_toe].copy()
if not np.isclose(rows_df[z_col].max(), z_toe):
    sv_toe = float(np.interp(z_toe, df_i[z_col].to_numpy(), df_i[sv_col].to_numpy()))
    def _layer_at_right(z):
        for L in layers:
            if L.top_depth <= z < L.bottom_depth: return L
        return layers[-1]
    Ka_toe = np.tan(np.deg2rad(45.0 - 0.5*(_layer_at_right(z_toe-1e-6).params.phi or 0.0)))**2
    p_toe = Ka_toe * sv_toe
    rows_df = pd.concat([rows_df, pd.DataFrame([{z_col: z_toe, p_up_c: p_toe, p_dn_c: p_toe}])],
                        ignore_index=True)
rows_df = rows_df.sort_values(z_col).reset_index(drop=True)
rows_active = rows_df.to_dict("records")

_, _, df_pass = compute_passive_pressures_left_with_interfaces(
    layers, Z=Z, t=t, water_table_depth=z_wt, gamma_w=9.81, surcharge_q=0.0
)
p_up_col = "p↑ = Kp↑·σ′v [kN/m²]"
p_dn_col = "p↓ = Kp↓·σ′v [kN/m²]"
df_pass_clip = df_pass[df_pass["z [m]"] <= z_toe].copy()
rows_p = df_pass_clip.sort_values("z [m]").to_dict("records")

pmax_active  = float(max(rows_df[p_up_c].max(),  rows_df[p_dn_c].max()))
pmax_passive = float(max(df_pass_clip[p_up_col].max(), df_pass_clip[p_dn_col].max()))
target = 0.40 * block_w
scale_both = target / max(pmax_active, pmax_passive, 1e-12)

x_ptsR, y_ptsR = [], []
if rows_active:
    x_ptsR.append(x_face_right + float(rows_active[0][p_dn_c]) * scale_both)
    y_ptsR.append(Z - float(rows_active[0][z_col]))
for i in range(len(rows_active) - 1):
    zb    = float(rows_active[i+1][z_col])
    p_end = float(rows_active[i+1][p_up_c])
    x1 = x_face_right + p_end * scale_both; y1 = Z - zb
    x_ptsR.append(x1); y_ptsR.append(y1)
    p_next = float(rows_active[i+1][p_dn_c])
    x_next = x_face_right + p_next * scale_both
    if abs(x1 - x_next) > 1e-12:
        x_ptsR.append(x_next); y_ptsR.append(y1)
xR, yR = np.array(x_ptsR), np.array(y_ptsR)
ax.plot(xR, yR, color="red", lw=2, label="Active Earth Pressure")
ax.fill_betweenx(yR, x_face_right, xR, color="red", alpha=0.30)

x_ptsL, y_ptsL = [], []
if rows_p:
    x_ptsL.append(x_face_left - float(rows_p[0][p_dn_col]) * scale_both)
    y_ptsL.append(Z - float(rows_p[0]["z [m]"]))
for i in range(len(rows_p) - 1):
    zb    = float(rows_p[i+1]["z [m]"])
    p_end = float(rows_p[i+1][p_up_col])
    x1 = x_face_left - p_end * scale_both; y1 = Z - zb
    x_ptsL.append(x1); y_ptsL.append(y1)
    p_next = float(rows_p[i+1][p_dn_col])
    x_next = x_face_left - p_next * scale_both
    if abs(x1 - x_next) > 1e-12:
        x_ptsL.append(x_next); y_ptsL.append(y1)
xL, yL = np.array(x_ptsL), np.array(y_ptsL)
ax.plot(xL, yL, color="navy", lw=2, label="Passive Earth Pressure")
ax.fill_betweenx(yL, xL, x_face_left, color="navy", alpha=0.30)

def _decompose_forces(rows, z_key, p_top_key, p_bot_key, z_start, z_end):
    """Split each [z_i,z_{i+1}] trapezoid into rectangle + triangle components."""
    segs = sorted([r for r in rows if z_start <= float(r[z_key]) <= z_end],
                  key=lambda r: float(r[z_key]))
    out = []
    for i in range(len(segs) - 1):
        zt = float(segs[i][z_key]); zb = float(segs[i+1][z_key]); H = zb - zt
        if H <= 0: 
            continue
        pt = float(segs[i][p_top_key])     # p just below the top interface
        pb = float(segs[i+1][p_bot_key])   # p just above the bottom interface

        pmin = min(pt, pb)
        dp   = pb - pt

        # Rectangle component
        F_rect  = pmin * H
        if F_rect > 1e-12:
            out.append(dict(F=F_rect, zc=zt + 0.5*H, kind="rect", i=i))

        # Triangle component
        F_tri   = 0.5 * abs(dp) * H
        if F_tri > 1e-12:
            zc_tri = zt + (2.0/3.0*H if dp > 0 else 1.0/3.0*H)
            out.append(dict(F=F_tri, zc=zc_tri, kind="tri", i=i))
    return out

active_comps  = _decompose_forces(rows_active, z_key=z_col,
                                  p_top_key=p_dn_c, p_bot_key=p_up_c,
                                  z_start=0.0, z_end=z_toe)

passive_comps = _decompose_forces(rows_p, z_key="z [m]",
                                  p_top_key=p_dn_col, p_bot_key=p_up_col,
                                  z_start=z_top, z_end=z_toe)

F_ref = max([c["F"] for c in (active_comps + passive_comps)] + [1e-12])
arrow_span   = 1 * block_w
arrow_scaleF = arrow_span / F_ref

def _draw_force_components_toward_wall(ax, comps, x_wall, to_wall_sign, color, prefix):
    """
    Draw each component as a horizontal arrow with the **head at the centroid** (point of action),
    pointing **into the wall**.
      - to_wall_sign: +1 → wall is to the RIGHT of soil (passive/left side)  → arrow points +x
                      -1 → wall is to the LEFT  of soil (active/right side)  → arrow points -x
    Uses annotate() so the arrow HEAD is at xy (centroid) with a smaller head.
    """
    comps = sorted(comps, key=lambda c: c["zc"])
    for k, c in enumerate(comps, start=1):
        L  = c["F"] * arrow_scaleF               # arrow length to show magnitude
        y  = Z - c["zc"]                         # centroid elevation

        # Draw a small tick at the PoA on the wall
        ax.plot([x_wall - 0.06, x_wall + 0.06], [y, y], color=color, lw=1.4)

        # Arrow HEAD at centroid on the wall; tail away from wall by length L
        # Smaller arrowhead via mutation_scale
        if to_wall_sign > 0:
            # passive: head at (x_wall, y), tail at (x_wall - L, y)
            xy     = (x_wall, y)
            xytext = (x_wall - L, y)
            ha_txt = "right"
            x_lab  = x_wall - L - 0.03*block_w
        else:
            # active: head at (x_wall, y), tail at (x_wall + L, y)
            xy     = (x_wall, y)
            xytext = (x_wall + L, y)
            ha_txt = "left"
            x_lab  = x_wall + L + 0.03*block_w

        ax.annotate(
            "", xy=xy, xytext=xytext,
            arrowprops=dict(
                arrowstyle="-|>",        # filled head at xy
                lw=2.0,
                color=color,
                mutation_scale=8.0       # <<< SMALLER HEAD
            )
        )

        # label near the tail side (away from wall) to keep clear of the head/PoA
        ax.text(
            x_lab, y + (0.06 if (k % 2) else -0.06),
            f"{prefix}{k} ({c['kind']}): {c['F']:.2f} kN/m",
            fontsize=7.5, ha=ha_txt, va="center", color=color
        )

_draw_force_components_toward_wall(ax, active_comps,  x_wall=x_face_right, to_wall_sign=-1, color="red",  prefix="Fₐ")
_draw_force_components_toward_wall(ax, passive_comps, x_wall=x_face_left,  to_wall_sign=+1, color="navy", prefix="Fₚ")

half_span = max(abs(COMMON_X_MIN - x_wall), abs(COMMON_X_MAX - x_wall))
ax.set_xlim(x_wall - half_span, x_wall + half_span)
ax.set_ylim(COMMON_Y_MIN, COMMON_Y_MAX + 1)

# position the axes in the middle of the figure canvas
dw = desired_width if 'desired_width' in globals() else 0.6
dh = desired_height if 'desired_height' in globals() else 0.8
left = (1.0 - dw) / 2.0
bottom = (1.0 - dh) / 2.0
ax.set_position([left, bottom, dw, dh])

ax.axis("off")
plt.show()
\end{lstlisting}
